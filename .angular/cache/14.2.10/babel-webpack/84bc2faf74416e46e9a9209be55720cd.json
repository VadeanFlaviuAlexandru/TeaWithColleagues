{"ast":null,"code":"import { Splitter, hasBgRendering, createFormatter, ViewContextType, ContentContainer, BaseComponent, DateComponent, diffDays, buildNavLinkAttrs, WeekNumberContainer, getStickyHeaderDates, ViewContainer, SimpleScrollGrid, getStickyFooterScrollbar, NowTimer, NowIndicatorContainer, renderScrollShim, rangeContainsMarker, startOfDay, asRoughMs, createDuration, RefMap, PositionCache, MoreLinkContainer, SegHierarchy, groupIntersectingEntries, binarySearch, getEntrySpanEnd, buildEntryKey, StandardEvent, memoize, sortEventSegs, DayCellContainer, hasCustomDayCellContent, getSegMeta, buildIsoString, computeEarliestSegStart, buildEventRangeKey, BgEvent, renderFill, addDurations, multiplyDuration, wholeDivideDurations, Slicer, intersectRanges, formatIsoTimeString, DayHeader, DaySeriesModel, DayTableModel } from '@fullcalendar/core/internal.js';\nimport { createElement, createRef, Fragment } from '@fullcalendar/core/preact.js';\nimport { DayTable } from '@fullcalendar/daygrid/internal.js';\n\nclass AllDaySplitter extends Splitter {\n  getKeyInfo() {\n    return {\n      allDay: {},\n      timed: {}\n    };\n  }\n\n  getKeysForDateSpan(dateSpan) {\n    if (dateSpan.allDay) {\n      return ['allDay'];\n    }\n\n    return ['timed'];\n  }\n\n  getKeysForEventDef(eventDef) {\n    if (!eventDef.allDay) {\n      return ['timed'];\n    }\n\n    if (hasBgRendering(eventDef)) {\n      return ['timed', 'allDay'];\n    }\n\n    return ['allDay'];\n  }\n\n}\n\nconst DEFAULT_SLAT_LABEL_FORMAT = createFormatter({\n  hour: 'numeric',\n  minute: '2-digit',\n  omitZeroMinute: true,\n  meridiem: 'short'\n});\n\nfunction TimeColsAxisCell(props) {\n  let classNames = ['fc-timegrid-slot', 'fc-timegrid-slot-label', props.isLabeled ? 'fc-scrollgrid-shrink' : 'fc-timegrid-slot-minor'];\n  return createElement(ViewContextType.Consumer, null, context => {\n    if (!props.isLabeled) {\n      return createElement(\"td\", {\n        className: classNames.join(' '),\n        \"data-time\": props.isoTimeStr\n      });\n    }\n\n    let {\n      dateEnv,\n      options,\n      viewApi\n    } = context;\n    let labelFormat = // TODO: fully pre-parse\n    options.slotLabelFormat == null ? DEFAULT_SLAT_LABEL_FORMAT : Array.isArray(options.slotLabelFormat) ? createFormatter(options.slotLabelFormat[0]) : createFormatter(options.slotLabelFormat);\n    let renderProps = {\n      level: 0,\n      time: props.time,\n      date: dateEnv.toDate(props.date),\n      view: viewApi,\n      text: dateEnv.format(props.date, labelFormat)\n    };\n    return createElement(ContentContainer, {\n      elTag: \"td\",\n      elClasses: classNames,\n      elAttrs: {\n        'data-time': props.isoTimeStr\n      },\n      renderProps: renderProps,\n      generatorName: \"slotLabelContent\",\n      generator: options.slotLabelContent || renderInnerContent,\n      classNameGenerator: options.slotLabelClassNames,\n      didMount: options.slotLabelDidMount,\n      willUnmount: options.slotLabelWillUnmount\n    }, InnerContent => createElement(\"div\", {\n      className: \"fc-timegrid-slot-label-frame fc-scrollgrid-shrink-frame\"\n    }, createElement(InnerContent, {\n      elTag: \"div\",\n      elClasses: ['fc-timegrid-slot-label-cushion', 'fc-scrollgrid-shrink-cushion']\n    })));\n  });\n}\n\nfunction renderInnerContent(props) {\n  return props.text;\n}\n\nclass TimeBodyAxis extends BaseComponent {\n  render() {\n    return this.props.slatMetas.map(slatMeta => createElement(\"tr\", {\n      key: slatMeta.key\n    }, createElement(TimeColsAxisCell, Object.assign({}, slatMeta))));\n  }\n\n}\n\nconst DEFAULT_WEEK_NUM_FORMAT = createFormatter({\n  week: 'short'\n});\nconst AUTO_ALL_DAY_MAX_EVENT_ROWS = 5;\n\nclass TimeColsView extends DateComponent {\n  constructor() {\n    super(...arguments);\n    this.allDaySplitter = new AllDaySplitter(); // for use by subclasses\n\n    this.headerElRef = createRef();\n    this.rootElRef = createRef();\n    this.scrollerElRef = createRef();\n    this.state = {\n      slatCoords: null\n    };\n\n    this.handleScrollTopRequest = scrollTop => {\n      let scrollerEl = this.scrollerElRef.current;\n\n      if (scrollerEl) {\n        // TODO: not sure how this could ever be null. weirdness with the reducer\n        scrollerEl.scrollTop = scrollTop;\n      }\n    };\n    /* Header Render Methods\n    ------------------------------------------------------------------------------------------------------------------*/\n\n\n    this.renderHeadAxis = (rowKey, frameHeight = '') => {\n      let {\n        options\n      } = this.context;\n      let {\n        dateProfile\n      } = this.props;\n      let range = dateProfile.renderRange;\n      let dayCnt = diffDays(range.start, range.end); // only do in day views (to avoid doing in week views that dont need it)\n\n      let navLinkAttrs = dayCnt === 1 ? buildNavLinkAttrs(this.context, range.start, 'week') : {};\n\n      if (options.weekNumbers && rowKey === 'day') {\n        return createElement(WeekNumberContainer, {\n          elTag: \"th\",\n          elClasses: ['fc-timegrid-axis', 'fc-scrollgrid-shrink'],\n          elAttrs: {\n            'aria-hidden': true\n          },\n          date: range.start,\n          defaultFormat: DEFAULT_WEEK_NUM_FORMAT\n        }, InnerContent => createElement(\"div\", {\n          className: ['fc-timegrid-axis-frame', 'fc-scrollgrid-shrink-frame', 'fc-timegrid-axis-frame-liquid'].join(' '),\n          style: {\n            height: frameHeight\n          }\n        }, createElement(InnerContent, {\n          elTag: \"a\",\n          elClasses: ['fc-timegrid-axis-cushion', 'fc-scrollgrid-shrink-cushion', 'fc-scrollgrid-sync-inner'],\n          elAttrs: navLinkAttrs\n        })));\n      }\n\n      return createElement(\"th\", {\n        \"aria-hidden\": true,\n        className: \"fc-timegrid-axis\"\n      }, createElement(\"div\", {\n        className: \"fc-timegrid-axis-frame\",\n        style: {\n          height: frameHeight\n        }\n      }));\n    };\n    /* Table Component Render Methods\n    ------------------------------------------------------------------------------------------------------------------*/\n    // only a one-way height sync. we don't send the axis inner-content height to the DayGrid,\n    // but DayGrid still needs to have classNames on inner elements in order to measure.\n\n\n    this.renderTableRowAxis = rowHeight => {\n      let {\n        options,\n        viewApi\n      } = this.context;\n      let renderProps = {\n        text: options.allDayText,\n        view: viewApi\n      };\n      return (// TODO: make reusable hook. used in list view too\n        createElement(ContentContainer, {\n          elTag: \"td\",\n          elClasses: ['fc-timegrid-axis', 'fc-scrollgrid-shrink'],\n          elAttrs: {\n            'aria-hidden': true\n          },\n          renderProps: renderProps,\n          generatorName: \"allDayContent\",\n          generator: options.allDayContent || renderAllDayInner,\n          classNameGenerator: options.allDayClassNames,\n          didMount: options.allDayDidMount,\n          willUnmount: options.allDayWillUnmount\n        }, InnerContent => createElement(\"div\", {\n          className: ['fc-timegrid-axis-frame', 'fc-scrollgrid-shrink-frame', rowHeight == null ? ' fc-timegrid-axis-frame-liquid' : ''].join(' '),\n          style: {\n            height: rowHeight\n          }\n        }, createElement(InnerContent, {\n          elTag: \"span\",\n          elClasses: ['fc-timegrid-axis-cushion', 'fc-scrollgrid-shrink-cushion', 'fc-scrollgrid-sync-inner']\n        })))\n      );\n    };\n\n    this.handleSlatCoords = slatCoords => {\n      this.setState({\n        slatCoords\n      });\n    };\n  } // rendering\n  // ----------------------------------------------------------------------------------------------------\n\n\n  renderSimpleLayout(headerRowContent, allDayContent, timeContent) {\n    let {\n      context,\n      props\n    } = this;\n    let sections = [];\n    let stickyHeaderDates = getStickyHeaderDates(context.options);\n\n    if (headerRowContent) {\n      sections.push({\n        type: 'header',\n        key: 'header',\n        isSticky: stickyHeaderDates,\n        chunk: {\n          elRef: this.headerElRef,\n          tableClassName: 'fc-col-header',\n          rowContent: headerRowContent\n        }\n      });\n    }\n\n    if (allDayContent) {\n      sections.push({\n        type: 'body',\n        key: 'all-day',\n        chunk: {\n          content: allDayContent\n        }\n      });\n      sections.push({\n        type: 'body',\n        key: 'all-day-divider',\n        outerContent: // TODO: rename to cellContent so don't need to define <tr>?\n        createElement(\"tr\", {\n          role: \"presentation\",\n          className: \"fc-scrollgrid-section\"\n        }, createElement(\"td\", {\n          className: 'fc-timegrid-divider ' + context.theme.getClass('tableCellShaded')\n        }))\n      });\n    }\n\n    sections.push({\n      type: 'body',\n      key: 'body',\n      liquid: true,\n      expandRows: Boolean(context.options.expandRows),\n      chunk: {\n        scrollerElRef: this.scrollerElRef,\n        content: timeContent\n      }\n    });\n    return createElement(ViewContainer, {\n      elRef: this.rootElRef,\n      elClasses: ['fc-timegrid'],\n      viewSpec: context.viewSpec\n    }, createElement(SimpleScrollGrid, {\n      liquid: !props.isHeightAuto && !props.forPrint,\n      collapsibleWidth: props.forPrint,\n      cols: [{\n        width: 'shrink'\n      }],\n      sections: sections\n    }));\n  }\n\n  renderHScrollLayout(headerRowContent, allDayContent, timeContent, colCnt, dayMinWidth, slatMetas, slatCoords) {\n    let ScrollGrid = this.context.pluginHooks.scrollGridImpl;\n\n    if (!ScrollGrid) {\n      throw new Error('No ScrollGrid implementation');\n    }\n\n    let {\n      context,\n      props\n    } = this;\n    let stickyHeaderDates = !props.forPrint && getStickyHeaderDates(context.options);\n    let stickyFooterScrollbar = !props.forPrint && getStickyFooterScrollbar(context.options);\n    let sections = [];\n\n    if (headerRowContent) {\n      sections.push({\n        type: 'header',\n        key: 'header',\n        isSticky: stickyHeaderDates,\n        syncRowHeights: true,\n        chunks: [{\n          key: 'axis',\n          rowContent: arg => createElement(\"tr\", {\n            role: \"presentation\"\n          }, this.renderHeadAxis('day', arg.rowSyncHeights[0]))\n        }, {\n          key: 'cols',\n          elRef: this.headerElRef,\n          tableClassName: 'fc-col-header',\n          rowContent: headerRowContent\n        }]\n      });\n    }\n\n    if (allDayContent) {\n      sections.push({\n        type: 'body',\n        key: 'all-day',\n        syncRowHeights: true,\n        chunks: [{\n          key: 'axis',\n          rowContent: contentArg => createElement(\"tr\", {\n            role: \"presentation\"\n          }, this.renderTableRowAxis(contentArg.rowSyncHeights[0]))\n        }, {\n          key: 'cols',\n          content: allDayContent\n        }]\n      });\n      sections.push({\n        key: 'all-day-divider',\n        type: 'body',\n        outerContent: // TODO: rename to cellContent so don't need to define <tr>?\n        createElement(\"tr\", {\n          role: \"presentation\",\n          className: \"fc-scrollgrid-section\"\n        }, createElement(\"td\", {\n          colSpan: 2,\n          className: 'fc-timegrid-divider ' + context.theme.getClass('tableCellShaded')\n        }))\n      });\n    }\n\n    let isNowIndicator = context.options.nowIndicator;\n    sections.push({\n      type: 'body',\n      key: 'body',\n      liquid: true,\n      expandRows: Boolean(context.options.expandRows),\n      chunks: [{\n        key: 'axis',\n        content: arg => // TODO: make this now-indicator arrow more DRY with TimeColsContent\n        createElement(\"div\", {\n          className: \"fc-timegrid-axis-chunk\"\n        }, createElement(\"table\", {\n          \"aria-hidden\": true,\n          style: {\n            height: arg.expandRows ? arg.clientHeight : ''\n          }\n        }, arg.tableColGroupNode, createElement(\"tbody\", null, createElement(TimeBodyAxis, {\n          slatMetas: slatMetas\n        }))), createElement(\"div\", {\n          className: \"fc-timegrid-now-indicator-container\"\n        }, createElement(NowTimer, {\n          unit: isNowIndicator ? 'minute' : 'day'\n          /* hacky */\n\n        }, nowDate => {\n          let nowIndicatorTop = isNowIndicator && slatCoords && slatCoords.safeComputeTop(nowDate); // might return void\n\n          if (typeof nowIndicatorTop === 'number') {\n            return createElement(NowIndicatorContainer, {\n              elClasses: ['fc-timegrid-now-indicator-arrow'],\n              elStyle: {\n                top: nowIndicatorTop\n              },\n              isAxis: true,\n              date: nowDate\n            });\n          }\n\n          return null;\n        })))\n      }, {\n        key: 'cols',\n        scrollerElRef: this.scrollerElRef,\n        content: timeContent\n      }]\n    });\n\n    if (stickyFooterScrollbar) {\n      sections.push({\n        key: 'footer',\n        type: 'footer',\n        isSticky: true,\n        chunks: [{\n          key: 'axis',\n          content: renderScrollShim\n        }, {\n          key: 'cols',\n          content: renderScrollShim\n        }]\n      });\n    }\n\n    return createElement(ViewContainer, {\n      elRef: this.rootElRef,\n      elClasses: ['fc-timegrid'],\n      viewSpec: context.viewSpec\n    }, createElement(ScrollGrid, {\n      liquid: !props.isHeightAuto && !props.forPrint,\n      collapsibleWidth: false,\n      colGroups: [{\n        width: 'shrink',\n        cols: [{\n          width: 'shrink'\n        }]\n      }, {\n        cols: [{\n          span: colCnt,\n          minWidth: dayMinWidth\n        }]\n      }],\n      sections: sections\n    }));\n  }\n  /* Dimensions\n  ------------------------------------------------------------------------------------------------------------------*/\n\n\n  getAllDayMaxEventProps() {\n    let {\n      dayMaxEvents,\n      dayMaxEventRows\n    } = this.context.options;\n\n    if (dayMaxEvents === true || dayMaxEventRows === true) {\n      // is auto?\n      dayMaxEvents = undefined;\n      dayMaxEventRows = AUTO_ALL_DAY_MAX_EVENT_ROWS; // make sure \"auto\" goes to a real number\n    }\n\n    return {\n      dayMaxEvents,\n      dayMaxEventRows\n    };\n  }\n\n}\n\nfunction renderAllDayInner(renderProps) {\n  return renderProps.text;\n}\n\nclass TimeColsSlatsCoords {\n  constructor(positions, dateProfile, slotDuration) {\n    this.positions = positions;\n    this.dateProfile = dateProfile;\n    this.slotDuration = slotDuration;\n  }\n\n  safeComputeTop(date) {\n    let {\n      dateProfile\n    } = this;\n\n    if (rangeContainsMarker(dateProfile.currentRange, date)) {\n      let startOfDayDate = startOfDay(date);\n      let timeMs = date.valueOf() - startOfDayDate.valueOf();\n\n      if (timeMs >= asRoughMs(dateProfile.slotMinTime) && timeMs < asRoughMs(dateProfile.slotMaxTime)) {\n        return this.computeTimeTop(createDuration(timeMs));\n      }\n    }\n\n    return null;\n  } // Computes the top coordinate, relative to the bounds of the grid, of the given date.\n  // A `startOfDayDate` must be given for avoiding ambiguity over how to treat midnight.\n\n\n  computeDateTop(when, startOfDayDate) {\n    if (!startOfDayDate) {\n      startOfDayDate = startOfDay(when);\n    }\n\n    return this.computeTimeTop(createDuration(when.valueOf() - startOfDayDate.valueOf()));\n  } // Computes the top coordinate, relative to the bounds of the grid, of the given time (a Duration).\n  // This is a makeshify way to compute the time-top. Assumes all slatMetas dates are uniform.\n  // Eventually allow computation with arbirary slat dates.\n\n\n  computeTimeTop(duration) {\n    let {\n      positions,\n      dateProfile\n    } = this;\n    let len = positions.els.length; // floating-point value of # of slots covered\n\n    let slatCoverage = (duration.milliseconds - asRoughMs(dateProfile.slotMinTime)) / asRoughMs(this.slotDuration);\n    let slatIndex;\n    let slatRemainder; // compute a floating-point number for how many slats should be progressed through.\n    // from 0 to number of slats (inclusive)\n    // constrained because slotMinTime/slotMaxTime might be customized.\n\n    slatCoverage = Math.max(0, slatCoverage);\n    slatCoverage = Math.min(len, slatCoverage); // an integer index of the furthest whole slat\n    // from 0 to number slats (*exclusive*, so len-1)\n\n    slatIndex = Math.floor(slatCoverage);\n    slatIndex = Math.min(slatIndex, len - 1); // how much further through the slatIndex slat (from 0.0-1.0) must be covered in addition.\n    // could be 1.0 if slatCoverage is covering *all* the slots\n\n    slatRemainder = slatCoverage - slatIndex;\n    return positions.tops[slatIndex] + positions.getHeight(slatIndex) * slatRemainder;\n  }\n\n}\n\nclass TimeColsSlatsBody extends BaseComponent {\n  render() {\n    let {\n      props,\n      context\n    } = this;\n    let {\n      options\n    } = context;\n    let {\n      slatElRefs\n    } = props;\n    return createElement(\"tbody\", null, props.slatMetas.map((slatMeta, i) => {\n      let renderProps = {\n        time: slatMeta.time,\n        date: context.dateEnv.toDate(slatMeta.date),\n        view: context.viewApi\n      };\n      return createElement(\"tr\", {\n        key: slatMeta.key,\n        ref: slatElRefs.createRef(slatMeta.key)\n      }, props.axis && createElement(TimeColsAxisCell, Object.assign({}, slatMeta)), createElement(ContentContainer, {\n        elTag: \"td\",\n        elClasses: ['fc-timegrid-slot', 'fc-timegrid-slot-lane', !slatMeta.isLabeled && 'fc-timegrid-slot-minor'],\n        elAttrs: {\n          'data-time': slatMeta.isoTimeStr\n        },\n        renderProps: renderProps,\n        generatorName: \"slotLaneContent\",\n        generator: options.slotLaneContent,\n        classNameGenerator: options.slotLaneClassNames,\n        didMount: options.slotLaneDidMount,\n        willUnmount: options.slotLaneWillUnmount\n      }));\n    }));\n  }\n\n}\n/*\nfor the horizontal \"slats\" that run width-wise. Has a time axis on a side. Depends on RTL.\n*/\n\n\nclass TimeColsSlats extends BaseComponent {\n  constructor() {\n    super(...arguments);\n    this.rootElRef = createRef();\n    this.slatElRefs = new RefMap();\n  }\n\n  render() {\n    let {\n      props,\n      context\n    } = this;\n    return createElement(\"div\", {\n      ref: this.rootElRef,\n      className: \"fc-timegrid-slots\"\n    }, createElement(\"table\", {\n      \"aria-hidden\": true,\n      className: context.theme.getClass('table'),\n      style: {\n        minWidth: props.tableMinWidth,\n        width: props.clientWidth,\n        height: props.minHeight\n      }\n    }, props.tableColGroupNode\n    /* relies on there only being a single <col> for the axis */\n    , createElement(TimeColsSlatsBody, {\n      slatElRefs: this.slatElRefs,\n      axis: props.axis,\n      slatMetas: props.slatMetas\n    })));\n  }\n\n  componentDidMount() {\n    this.updateSizing();\n  }\n\n  componentDidUpdate() {\n    this.updateSizing();\n  }\n\n  componentWillUnmount() {\n    if (this.props.onCoords) {\n      this.props.onCoords(null);\n    }\n  }\n\n  updateSizing() {\n    let {\n      context,\n      props\n    } = this;\n\n    if (props.onCoords && props.clientWidth !== null // means sizing has stabilized\n    ) {\n      let rootEl = this.rootElRef.current;\n\n      if (rootEl.offsetHeight) {\n        // not hidden by css\n        props.onCoords(new TimeColsSlatsCoords(new PositionCache(this.rootElRef.current, collectSlatEls(this.slatElRefs.currentMap, props.slatMetas), false, true), this.props.dateProfile, context.options.slotDuration));\n      }\n    }\n  }\n\n}\n\nfunction collectSlatEls(elMap, slatMetas) {\n  return slatMetas.map(slatMeta => elMap[slatMeta.key]);\n}\n\nfunction splitSegsByCol(segs, colCnt) {\n  let segsByCol = [];\n  let i;\n\n  for (i = 0; i < colCnt; i += 1) {\n    segsByCol.push([]);\n  }\n\n  if (segs) {\n    for (i = 0; i < segs.length; i += 1) {\n      segsByCol[segs[i].col].push(segs[i]);\n    }\n  }\n\n  return segsByCol;\n}\n\nfunction splitInteractionByCol(ui, colCnt) {\n  let byRow = [];\n\n  if (!ui) {\n    for (let i = 0; i < colCnt; i += 1) {\n      byRow[i] = null;\n    }\n  } else {\n    for (let i = 0; i < colCnt; i += 1) {\n      byRow[i] = {\n        affectedInstances: ui.affectedInstances,\n        isEvent: ui.isEvent,\n        segs: []\n      };\n    }\n\n    for (let seg of ui.segs) {\n      byRow[seg.col].segs.push(seg);\n    }\n  }\n\n  return byRow;\n}\n\nclass TimeColMoreLink extends BaseComponent {\n  render() {\n    let {\n      props\n    } = this;\n    return createElement(MoreLinkContainer, {\n      elClasses: ['fc-timegrid-more-link'],\n      elStyle: {\n        top: props.top,\n        bottom: props.bottom\n      },\n      allDayDate: null,\n      moreCnt: props.hiddenSegs.length,\n      allSegs: props.hiddenSegs,\n      hiddenSegs: props.hiddenSegs,\n      extraDateSpan: props.extraDateSpan,\n      dateProfile: props.dateProfile,\n      todayRange: props.todayRange,\n      popoverContent: () => renderPlainFgSegs(props.hiddenSegs, props),\n      defaultGenerator: renderMoreLinkInner\n    }, InnerContent => createElement(InnerContent, {\n      elTag: \"div\",\n      elClasses: ['fc-timegrid-more-link-inner', 'fc-sticky']\n    }));\n  }\n\n}\n\nfunction renderMoreLinkInner(props) {\n  return props.shortText;\n} // segInputs assumed sorted\n\n\nfunction buildPositioning(segInputs, strictOrder, maxStackCnt) {\n  let hierarchy = new SegHierarchy();\n\n  if (strictOrder != null) {\n    hierarchy.strictOrder = strictOrder;\n  }\n\n  if (maxStackCnt != null) {\n    hierarchy.maxStackCnt = maxStackCnt;\n  }\n\n  let hiddenEntries = hierarchy.addSegs(segInputs);\n  let hiddenGroups = groupIntersectingEntries(hiddenEntries);\n  let web = buildWeb(hierarchy);\n  web = stretchWeb(web, 1); // all levelCoords/thickness will have 0.0-1.0\n\n  let segRects = webToRects(web);\n  return {\n    segRects,\n    hiddenGroups\n  };\n}\n\nfunction buildWeb(hierarchy) {\n  const {\n    entriesByLevel\n  } = hierarchy;\n  const buildNode = cacheable((level, lateral) => level + ':' + lateral, (level, lateral) => {\n    let siblingRange = findNextLevelSegs(hierarchy, level, lateral);\n    let nextLevelRes = buildNodes(siblingRange, buildNode);\n    let entry = entriesByLevel[level][lateral];\n    return [Object.assign(Object.assign({}, entry), {\n      nextLevelNodes: nextLevelRes[0]\n    }), entry.thickness + nextLevelRes[1] // the pressure builds\n    ];\n  });\n  return buildNodes(entriesByLevel.length ? {\n    level: 0,\n    lateralStart: 0,\n    lateralEnd: entriesByLevel[0].length\n  } : null, buildNode)[0];\n}\n\nfunction buildNodes(siblingRange, buildNode) {\n  if (!siblingRange) {\n    return [[], 0];\n  }\n\n  let {\n    level,\n    lateralStart,\n    lateralEnd\n  } = siblingRange;\n  let lateral = lateralStart;\n  let pairs = [];\n\n  while (lateral < lateralEnd) {\n    pairs.push(buildNode(level, lateral));\n    lateral += 1;\n  }\n\n  pairs.sort(cmpDescPressures);\n  return [pairs.map(extractNode), pairs[0][1] // first item's pressure\n  ];\n}\n\nfunction cmpDescPressures(a, b) {\n  return b[1] - a[1];\n}\n\nfunction extractNode(a) {\n  return a[0];\n}\n\nfunction findNextLevelSegs(hierarchy, subjectLevel, subjectLateral) {\n  let {\n    levelCoords,\n    entriesByLevel\n  } = hierarchy;\n  let subjectEntry = entriesByLevel[subjectLevel][subjectLateral];\n  let afterSubject = levelCoords[subjectLevel] + subjectEntry.thickness;\n  let levelCnt = levelCoords.length;\n  let level = subjectLevel; // skip past levels that are too high up\n\n  for (; level < levelCnt && levelCoords[level] < afterSubject; level += 1); // do nothing\n\n\n  for (; level < levelCnt; level += 1) {\n    let entries = entriesByLevel[level];\n    let entry;\n    let searchIndex = binarySearch(entries, subjectEntry.span.start, getEntrySpanEnd);\n    let lateralStart = searchIndex[0] + searchIndex[1]; // if exact match (which doesn't collide), go to next one\n\n    let lateralEnd = lateralStart;\n\n    while ( // loop through entries that horizontally intersect\n    (entry = entries[lateralEnd]) && // but not past the whole seg list\n    entry.span.start < subjectEntry.span.end) {\n      lateralEnd += 1;\n    }\n\n    if (lateralStart < lateralEnd) {\n      return {\n        level,\n        lateralStart,\n        lateralEnd\n      };\n    }\n  }\n\n  return null;\n}\n\nfunction stretchWeb(topLevelNodes, totalThickness) {\n  const stretchNode = cacheable((node, startCoord, prevThickness) => buildEntryKey(node), (node, startCoord, prevThickness) => {\n    let {\n      nextLevelNodes,\n      thickness\n    } = node;\n    let allThickness = thickness + prevThickness;\n    let thicknessFraction = thickness / allThickness;\n    let endCoord;\n    let newChildren = [];\n\n    if (!nextLevelNodes.length) {\n      endCoord = totalThickness;\n    } else {\n      for (let childNode of nextLevelNodes) {\n        if (endCoord === undefined) {\n          let res = stretchNode(childNode, startCoord, allThickness);\n          endCoord = res[0];\n          newChildren.push(res[1]);\n        } else {\n          let res = stretchNode(childNode, endCoord, 0);\n          newChildren.push(res[1]);\n        }\n      }\n    }\n\n    let newThickness = (endCoord - startCoord) * thicknessFraction;\n    return [endCoord - newThickness, Object.assign(Object.assign({}, node), {\n      thickness: newThickness,\n      nextLevelNodes: newChildren\n    })];\n  });\n  return topLevelNodes.map(node => stretchNode(node, 0, 0)[1]);\n} // not sorted in any particular order\n\n\nfunction webToRects(topLevelNodes) {\n  let rects = [];\n  const processNode = cacheable((node, levelCoord, stackDepth) => buildEntryKey(node), (node, levelCoord, stackDepth) => {\n    let rect = Object.assign(Object.assign({}, node), {\n      levelCoord,\n      stackDepth,\n      stackForward: 0\n    });\n    rects.push(rect);\n    return rect.stackForward = processNodes(node.nextLevelNodes, levelCoord + node.thickness, stackDepth + 1) + 1;\n  });\n\n  function processNodes(nodes, levelCoord, stackDepth) {\n    let stackForward = 0;\n\n    for (let node of nodes) {\n      stackForward = Math.max(processNode(node, levelCoord, stackDepth), stackForward);\n    }\n\n    return stackForward;\n  }\n\n  processNodes(topLevelNodes, 0, 0);\n  return rects; // TODO: sort rects by levelCoord to be consistent with toRects?\n} // TODO: move to general util\n\n\nfunction cacheable(keyFunc, workFunc) {\n  const cache = {};\n  return (...args) => {\n    let key = keyFunc(...args);\n    return key in cache ? cache[key] : cache[key] = workFunc(...args);\n  };\n}\n\nfunction computeSegVCoords(segs, colDate, slatCoords = null, eventMinHeight = 0) {\n  let vcoords = [];\n\n  if (slatCoords) {\n    for (let i = 0; i < segs.length; i += 1) {\n      let seg = segs[i];\n      let spanStart = slatCoords.computeDateTop(seg.start, colDate);\n      let spanEnd = Math.max(spanStart + (eventMinHeight || 0), // :(\n      slatCoords.computeDateTop(seg.end, colDate));\n      vcoords.push({\n        start: Math.round(spanStart),\n        end: Math.round(spanEnd) //\n\n      });\n    }\n  }\n\n  return vcoords;\n}\n\nfunction computeFgSegPlacements(segs, segVCoords, // might not have for every seg\neventOrderStrict, eventMaxStack) {\n  let segInputs = [];\n  let dumbSegs = []; // segs without coords\n\n  for (let i = 0; i < segs.length; i += 1) {\n    let vcoords = segVCoords[i];\n\n    if (vcoords) {\n      segInputs.push({\n        index: i,\n        thickness: 1,\n        span: vcoords\n      });\n    } else {\n      dumbSegs.push(segs[i]);\n    }\n  }\n\n  let {\n    segRects,\n    hiddenGroups\n  } = buildPositioning(segInputs, eventOrderStrict, eventMaxStack);\n  let segPlacements = [];\n\n  for (let segRect of segRects) {\n    segPlacements.push({\n      seg: segs[segRect.index],\n      rect: segRect\n    });\n  }\n\n  for (let dumbSeg of dumbSegs) {\n    segPlacements.push({\n      seg: dumbSeg,\n      rect: null\n    });\n  }\n\n  return {\n    segPlacements,\n    hiddenGroups\n  };\n}\n\nconst DEFAULT_TIME_FORMAT = createFormatter({\n  hour: 'numeric',\n  minute: '2-digit',\n  meridiem: false\n});\n\nclass TimeColEvent extends BaseComponent {\n  render() {\n    return createElement(StandardEvent, Object.assign({}, this.props, {\n      elClasses: ['fc-timegrid-event', 'fc-v-event', this.props.isShort && 'fc-timegrid-event-short'],\n      defaultTimeFormat: DEFAULT_TIME_FORMAT\n    }));\n  }\n\n}\n\nclass TimeCol extends BaseComponent {\n  constructor() {\n    super(...arguments);\n    this.sortEventSegs = memoize(sortEventSegs);\n  } // TODO: memoize event-placement?\n\n\n  render() {\n    let {\n      props,\n      context\n    } = this;\n    let {\n      options\n    } = context;\n    let isSelectMirror = options.selectMirror;\n    let mirrorSegs = // yuck\n    props.eventDrag && props.eventDrag.segs || props.eventResize && props.eventResize.segs || isSelectMirror && props.dateSelectionSegs || [];\n    let interactionAffectedInstances = // TODO: messy way to compute this\n    props.eventDrag && props.eventDrag.affectedInstances || props.eventResize && props.eventResize.affectedInstances || {};\n    let sortedFgSegs = this.sortEventSegs(props.fgEventSegs, options.eventOrder);\n    return createElement(DayCellContainer, {\n      elTag: \"td\",\n      elRef: props.elRef,\n      elClasses: ['fc-timegrid-col', ...(props.extraClassNames || [])],\n      elAttrs: Object.assign({\n        role: 'gridcell'\n      }, props.extraDataAttrs),\n      date: props.date,\n      dateProfile: props.dateProfile,\n      todayRange: props.todayRange,\n      extraRenderProps: props.extraRenderProps\n    }, InnerContent => createElement(\"div\", {\n      className: \"fc-timegrid-col-frame\"\n    }, createElement(\"div\", {\n      className: \"fc-timegrid-col-bg\"\n    }, this.renderFillSegs(props.businessHourSegs, 'non-business'), this.renderFillSegs(props.bgEventSegs, 'bg-event'), this.renderFillSegs(props.dateSelectionSegs, 'highlight')), createElement(\"div\", {\n      className: \"fc-timegrid-col-events\"\n    }, this.renderFgSegs(sortedFgSegs, interactionAffectedInstances, false, false, false)), createElement(\"div\", {\n      className: \"fc-timegrid-col-events\"\n    }, this.renderFgSegs(mirrorSegs, {}, Boolean(props.eventDrag), Boolean(props.eventResize), Boolean(isSelectMirror))), createElement(\"div\", {\n      className: \"fc-timegrid-now-indicator-container\"\n    }, this.renderNowIndicator(props.nowIndicatorSegs)), hasCustomDayCellContent(options) && createElement(InnerContent, {\n      elTag: \"div\",\n      elClasses: ['fc-timegrid-col-misc']\n    })));\n  }\n\n  renderFgSegs(sortedFgSegs, segIsInvisible, isDragging, isResizing, isDateSelecting) {\n    let {\n      props\n    } = this;\n\n    if (props.forPrint) {\n      return renderPlainFgSegs(sortedFgSegs, props);\n    }\n\n    return this.renderPositionedFgSegs(sortedFgSegs, segIsInvisible, isDragging, isResizing, isDateSelecting);\n  }\n\n  renderPositionedFgSegs(segs, // if not mirror, needs to be sorted\n  segIsInvisible, isDragging, isResizing, isDateSelecting) {\n    let {\n      eventMaxStack,\n      eventShortHeight,\n      eventOrderStrict,\n      eventMinHeight\n    } = this.context.options;\n    let {\n      date,\n      slatCoords,\n      eventSelection,\n      todayRange,\n      nowDate\n    } = this.props;\n    let isMirror = isDragging || isResizing || isDateSelecting;\n    let segVCoords = computeSegVCoords(segs, date, slatCoords, eventMinHeight);\n    let {\n      segPlacements,\n      hiddenGroups\n    } = computeFgSegPlacements(segs, segVCoords, eventOrderStrict, eventMaxStack);\n    return createElement(Fragment, null, this.renderHiddenGroups(hiddenGroups, segs), segPlacements.map(segPlacement => {\n      let {\n        seg,\n        rect\n      } = segPlacement;\n      let instanceId = seg.eventRange.instance.instanceId;\n      let isVisible = isMirror || Boolean(!segIsInvisible[instanceId] && rect);\n      let vStyle = computeSegVStyle(rect && rect.span);\n      let hStyle = !isMirror && rect ? this.computeSegHStyle(rect) : {\n        left: 0,\n        right: 0\n      };\n      let isInset = Boolean(rect) && rect.stackForward > 0;\n      let isShort = Boolean(rect) && rect.span.end - rect.span.start < eventShortHeight; // look at other places for this problem\n\n      return createElement(\"div\", {\n        className: 'fc-timegrid-event-harness' + (isInset ? ' fc-timegrid-event-harness-inset' : ''),\n        key: instanceId,\n        style: Object.assign(Object.assign({\n          visibility: isVisible ? '' : 'hidden'\n        }, vStyle), hStyle)\n      }, createElement(TimeColEvent, Object.assign({\n        seg: seg,\n        isDragging: isDragging,\n        isResizing: isResizing,\n        isDateSelecting: isDateSelecting,\n        isSelected: instanceId === eventSelection,\n        isShort: isShort\n      }, getSegMeta(seg, todayRange, nowDate))));\n    }));\n  } // will already have eventMinHeight applied because segInputs already had it\n\n\n  renderHiddenGroups(hiddenGroups, segs) {\n    let {\n      extraDateSpan,\n      dateProfile,\n      todayRange,\n      nowDate,\n      eventSelection,\n      eventDrag,\n      eventResize\n    } = this.props;\n    return createElement(Fragment, null, hiddenGroups.map(hiddenGroup => {\n      let positionCss = computeSegVStyle(hiddenGroup.span);\n      let hiddenSegs = compileSegsFromEntries(hiddenGroup.entries, segs);\n      return createElement(TimeColMoreLink, {\n        key: buildIsoString(computeEarliestSegStart(hiddenSegs)),\n        hiddenSegs: hiddenSegs,\n        top: positionCss.top,\n        bottom: positionCss.bottom,\n        extraDateSpan: extraDateSpan,\n        dateProfile: dateProfile,\n        todayRange: todayRange,\n        nowDate: nowDate,\n        eventSelection: eventSelection,\n        eventDrag: eventDrag,\n        eventResize: eventResize\n      });\n    }));\n  }\n\n  renderFillSegs(segs, fillType) {\n    let {\n      props,\n      context\n    } = this;\n    let segVCoords = computeSegVCoords(segs, props.date, props.slatCoords, context.options.eventMinHeight); // don't assume all populated\n\n    let children = segVCoords.map((vcoords, i) => {\n      let seg = segs[i];\n      return createElement(\"div\", {\n        key: buildEventRangeKey(seg.eventRange),\n        className: \"fc-timegrid-bg-harness\",\n        style: computeSegVStyle(vcoords)\n      }, fillType === 'bg-event' ? createElement(BgEvent, Object.assign({\n        seg: seg\n      }, getSegMeta(seg, props.todayRange, props.nowDate))) : renderFill(fillType));\n    });\n    return createElement(Fragment, null, children);\n  }\n\n  renderNowIndicator(segs) {\n    let {\n      slatCoords,\n      date\n    } = this.props;\n\n    if (!slatCoords) {\n      return null;\n    }\n\n    return segs.map((seg, i) => createElement(NowIndicatorContainer // key doesn't matter. will only ever be one\n    , {\n      // key doesn't matter. will only ever be one\n      key: i,\n      elClasses: ['fc-timegrid-now-indicator-line'],\n      elStyle: {\n        top: slatCoords.computeDateTop(seg.start, date)\n      },\n      isAxis: false,\n      date: date\n    }));\n  }\n\n  computeSegHStyle(segHCoords) {\n    let {\n      isRtl,\n      options\n    } = this.context;\n    let shouldOverlap = options.slotEventOverlap;\n    let nearCoord = segHCoords.levelCoord; // the left side if LTR. the right side if RTL. floating-point\n\n    let farCoord = segHCoords.levelCoord + segHCoords.thickness; // the right side if LTR. the left side if RTL. floating-point\n\n    let left; // amount of space from left edge, a fraction of the total width\n\n    let right; // amount of space from right edge, a fraction of the total width\n\n    if (shouldOverlap) {\n      // double the width, but don't go beyond the maximum forward coordinate (1.0)\n      farCoord = Math.min(1, nearCoord + (farCoord - nearCoord) * 2);\n    }\n\n    if (isRtl) {\n      left = 1 - farCoord;\n      right = nearCoord;\n    } else {\n      left = nearCoord;\n      right = 1 - farCoord;\n    }\n\n    let props = {\n      zIndex: segHCoords.stackDepth + 1,\n      left: left * 100 + '%',\n      right: right * 100 + '%'\n    };\n\n    if (shouldOverlap && !segHCoords.stackForward) {\n      // add padding to the edge so that forward stacked events don't cover the resizer's icon\n      props[isRtl ? 'marginLeft' : 'marginRight'] = 10 * 2; // 10 is a guesstimate of the icon's width\n    }\n\n    return props;\n  }\n\n}\n\nfunction renderPlainFgSegs(sortedFgSegs, {\n  todayRange,\n  nowDate,\n  eventSelection,\n  eventDrag,\n  eventResize\n}) {\n  let hiddenInstances = (eventDrag ? eventDrag.affectedInstances : null) || (eventResize ? eventResize.affectedInstances : null) || {};\n  return createElement(Fragment, null, sortedFgSegs.map(seg => {\n    let instanceId = seg.eventRange.instance.instanceId;\n    return createElement(\"div\", {\n      key: instanceId,\n      style: {\n        visibility: hiddenInstances[instanceId] ? 'hidden' : ''\n      }\n    }, createElement(TimeColEvent, Object.assign({\n      seg: seg,\n      isDragging: false,\n      isResizing: false,\n      isDateSelecting: false,\n      isSelected: instanceId === eventSelection,\n      isShort: false\n    }, getSegMeta(seg, todayRange, nowDate))));\n  }));\n}\n\nfunction computeSegVStyle(segVCoords) {\n  if (!segVCoords) {\n    return {\n      top: '',\n      bottom: ''\n    };\n  }\n\n  return {\n    top: segVCoords.start,\n    bottom: -segVCoords.end\n  };\n}\n\nfunction compileSegsFromEntries(segEntries, allSegs) {\n  return segEntries.map(segEntry => allSegs[segEntry.index]);\n}\n\nclass TimeColsContent extends BaseComponent {\n  constructor() {\n    super(...arguments);\n    this.splitFgEventSegs = memoize(splitSegsByCol);\n    this.splitBgEventSegs = memoize(splitSegsByCol);\n    this.splitBusinessHourSegs = memoize(splitSegsByCol);\n    this.splitNowIndicatorSegs = memoize(splitSegsByCol);\n    this.splitDateSelectionSegs = memoize(splitSegsByCol);\n    this.splitEventDrag = memoize(splitInteractionByCol);\n    this.splitEventResize = memoize(splitInteractionByCol);\n    this.rootElRef = createRef();\n    this.cellElRefs = new RefMap();\n  }\n\n  render() {\n    let {\n      props,\n      context\n    } = this;\n    let nowIndicatorTop = context.options.nowIndicator && props.slatCoords && props.slatCoords.safeComputeTop(props.nowDate); // might return void\n\n    let colCnt = props.cells.length;\n    let fgEventSegsByRow = this.splitFgEventSegs(props.fgEventSegs, colCnt);\n    let bgEventSegsByRow = this.splitBgEventSegs(props.bgEventSegs, colCnt);\n    let businessHourSegsByRow = this.splitBusinessHourSegs(props.businessHourSegs, colCnt);\n    let nowIndicatorSegsByRow = this.splitNowIndicatorSegs(props.nowIndicatorSegs, colCnt);\n    let dateSelectionSegsByRow = this.splitDateSelectionSegs(props.dateSelectionSegs, colCnt);\n    let eventDragByRow = this.splitEventDrag(props.eventDrag, colCnt);\n    let eventResizeByRow = this.splitEventResize(props.eventResize, colCnt);\n    return createElement(\"div\", {\n      className: \"fc-timegrid-cols\",\n      ref: this.rootElRef\n    }, createElement(\"table\", {\n      role: \"presentation\",\n      style: {\n        minWidth: props.tableMinWidth,\n        width: props.clientWidth\n      }\n    }, props.tableColGroupNode, createElement(\"tbody\", {\n      role: \"presentation\"\n    }, createElement(\"tr\", {\n      role: \"row\"\n    }, props.axis && createElement(\"td\", {\n      \"aria-hidden\": true,\n      className: \"fc-timegrid-col fc-timegrid-axis\"\n    }, createElement(\"div\", {\n      className: \"fc-timegrid-col-frame\"\n    }, createElement(\"div\", {\n      className: \"fc-timegrid-now-indicator-container\"\n    }, typeof nowIndicatorTop === 'number' && createElement(NowIndicatorContainer, {\n      elClasses: ['fc-timegrid-now-indicator-arrow'],\n      elStyle: {\n        top: nowIndicatorTop\n      },\n      isAxis: true,\n      date: props.nowDate\n    })))), props.cells.map((cell, i) => createElement(TimeCol, {\n      key: cell.key,\n      elRef: this.cellElRefs.createRef(cell.key),\n      dateProfile: props.dateProfile,\n      date: cell.date,\n      nowDate: props.nowDate,\n      todayRange: props.todayRange,\n      extraRenderProps: cell.extraRenderProps,\n      extraDataAttrs: cell.extraDataAttrs,\n      extraClassNames: cell.extraClassNames,\n      extraDateSpan: cell.extraDateSpan,\n      fgEventSegs: fgEventSegsByRow[i],\n      bgEventSegs: bgEventSegsByRow[i],\n      businessHourSegs: businessHourSegsByRow[i],\n      nowIndicatorSegs: nowIndicatorSegsByRow[i],\n      dateSelectionSegs: dateSelectionSegsByRow[i],\n      eventDrag: eventDragByRow[i],\n      eventResize: eventResizeByRow[i],\n      slatCoords: props.slatCoords,\n      eventSelection: props.eventSelection,\n      forPrint: props.forPrint\n    }))))));\n  }\n\n  componentDidMount() {\n    this.updateCoords();\n  }\n\n  componentDidUpdate() {\n    this.updateCoords();\n  }\n\n  updateCoords() {\n    let {\n      props\n    } = this;\n\n    if (props.onColCoords && props.clientWidth !== null // means sizing has stabilized\n    ) {\n      props.onColCoords(new PositionCache(this.rootElRef.current, collectCellEls(this.cellElRefs.currentMap, props.cells), true, // horizontal\n      false));\n    }\n  }\n\n}\n\nfunction collectCellEls(elMap, cells) {\n  return cells.map(cell => elMap[cell.key]);\n}\n/* A component that renders one or more columns of vertical time slots\n----------------------------------------------------------------------------------------------------------------------*/\n\n\nclass TimeCols extends DateComponent {\n  constructor() {\n    super(...arguments);\n    this.processSlotOptions = memoize(processSlotOptions);\n    this.state = {\n      slatCoords: null\n    };\n\n    this.handleRootEl = el => {\n      if (el) {\n        this.context.registerInteractiveComponent(this, {\n          el,\n          isHitComboAllowed: this.props.isHitComboAllowed\n        });\n      } else {\n        this.context.unregisterInteractiveComponent(this);\n      }\n    };\n\n    this.handleScrollRequest = request => {\n      let {\n        onScrollTopRequest\n      } = this.props;\n      let {\n        slatCoords\n      } = this.state;\n\n      if (onScrollTopRequest && slatCoords) {\n        if (request.time) {\n          let top = slatCoords.computeTimeTop(request.time);\n          top = Math.ceil(top); // zoom can give weird floating-point values. rather scroll a little bit further\n\n          if (top) {\n            top += 1; // to overcome top border that slots beyond the first have. looks better\n          }\n\n          onScrollTopRequest(top);\n        }\n\n        return true;\n      }\n\n      return false;\n    };\n\n    this.handleColCoords = colCoords => {\n      this.colCoords = colCoords;\n    };\n\n    this.handleSlatCoords = slatCoords => {\n      this.setState({\n        slatCoords\n      });\n\n      if (this.props.onSlatCoords) {\n        this.props.onSlatCoords(slatCoords);\n      }\n    };\n  }\n\n  render() {\n    let {\n      props,\n      state\n    } = this;\n    return createElement(\"div\", {\n      className: \"fc-timegrid-body\",\n      ref: this.handleRootEl,\n      style: {\n        // these props are important to give this wrapper correct dimensions for interactions\n        // TODO: if we set it here, can we avoid giving to inner tables?\n        width: props.clientWidth,\n        minWidth: props.tableMinWidth\n      }\n    }, createElement(TimeColsSlats, {\n      axis: props.axis,\n      dateProfile: props.dateProfile,\n      slatMetas: props.slatMetas,\n      clientWidth: props.clientWidth,\n      minHeight: props.expandRows ? props.clientHeight : '',\n      tableMinWidth: props.tableMinWidth,\n      tableColGroupNode: props.axis ? props.tableColGroupNode : null\n      /* axis depends on the colgroup's shrinking */\n      ,\n      onCoords: this.handleSlatCoords\n    }), createElement(TimeColsContent, {\n      cells: props.cells,\n      axis: props.axis,\n      dateProfile: props.dateProfile,\n      businessHourSegs: props.businessHourSegs,\n      bgEventSegs: props.bgEventSegs,\n      fgEventSegs: props.fgEventSegs,\n      dateSelectionSegs: props.dateSelectionSegs,\n      eventSelection: props.eventSelection,\n      eventDrag: props.eventDrag,\n      eventResize: props.eventResize,\n      todayRange: props.todayRange,\n      nowDate: props.nowDate,\n      nowIndicatorSegs: props.nowIndicatorSegs,\n      clientWidth: props.clientWidth,\n      tableMinWidth: props.tableMinWidth,\n      tableColGroupNode: props.tableColGroupNode,\n      slatCoords: state.slatCoords,\n      onColCoords: this.handleColCoords,\n      forPrint: props.forPrint\n    }));\n  }\n\n  componentDidMount() {\n    this.scrollResponder = this.context.createScrollResponder(this.handleScrollRequest);\n  }\n\n  componentDidUpdate(prevProps) {\n    this.scrollResponder.update(prevProps.dateProfile !== this.props.dateProfile);\n  }\n\n  componentWillUnmount() {\n    this.scrollResponder.detach();\n  }\n\n  queryHit(positionLeft, positionTop) {\n    let {\n      dateEnv,\n      options\n    } = this.context;\n    let {\n      colCoords\n    } = this;\n    let {\n      dateProfile\n    } = this.props;\n    let {\n      slatCoords\n    } = this.state;\n    let {\n      snapDuration,\n      snapsPerSlot\n    } = this.processSlotOptions(this.props.slotDuration, options.snapDuration);\n    let colIndex = colCoords.leftToIndex(positionLeft);\n    let slatIndex = slatCoords.positions.topToIndex(positionTop);\n\n    if (colIndex != null && slatIndex != null) {\n      let cell = this.props.cells[colIndex];\n      let slatTop = slatCoords.positions.tops[slatIndex];\n      let slatHeight = slatCoords.positions.getHeight(slatIndex);\n      let partial = (positionTop - slatTop) / slatHeight; // floating point number between 0 and 1\n\n      let localSnapIndex = Math.floor(partial * snapsPerSlot); // the snap # relative to start of slat\n\n      let snapIndex = slatIndex * snapsPerSlot + localSnapIndex;\n      let dayDate = this.props.cells[colIndex].date;\n      let time = addDurations(dateProfile.slotMinTime, multiplyDuration(snapDuration, snapIndex));\n      let start = dateEnv.add(dayDate, time);\n      let end = dateEnv.add(start, snapDuration);\n      return {\n        dateProfile,\n        dateSpan: Object.assign({\n          range: {\n            start,\n            end\n          },\n          allDay: false\n        }, cell.extraDateSpan),\n        dayEl: colCoords.els[colIndex],\n        rect: {\n          left: colCoords.lefts[colIndex],\n          right: colCoords.rights[colIndex],\n          top: slatTop,\n          bottom: slatTop + slatHeight\n        },\n        layer: 0\n      };\n    }\n\n    return null;\n  }\n\n}\n\nfunction processSlotOptions(slotDuration, snapDurationOverride) {\n  let snapDuration = snapDurationOverride || slotDuration;\n  let snapsPerSlot = wholeDivideDurations(slotDuration, snapDuration);\n\n  if (snapsPerSlot === null) {\n    snapDuration = slotDuration;\n    snapsPerSlot = 1; // TODO: say warning?\n  }\n\n  return {\n    snapDuration,\n    snapsPerSlot\n  };\n}\n\nclass DayTimeColsSlicer extends Slicer {\n  sliceRange(range, dayRanges) {\n    let segs = [];\n\n    for (let col = 0; col < dayRanges.length; col += 1) {\n      let segRange = intersectRanges(range, dayRanges[col]);\n\n      if (segRange) {\n        segs.push({\n          start: segRange.start,\n          end: segRange.end,\n          isStart: segRange.start.valueOf() === range.start.valueOf(),\n          isEnd: segRange.end.valueOf() === range.end.valueOf(),\n          col\n        });\n      }\n    }\n\n    return segs;\n  }\n\n}\n\nclass DayTimeCols extends DateComponent {\n  constructor() {\n    super(...arguments);\n    this.buildDayRanges = memoize(buildDayRanges);\n    this.slicer = new DayTimeColsSlicer();\n    this.timeColsRef = createRef();\n  }\n\n  render() {\n    let {\n      props,\n      context\n    } = this;\n    let {\n      dateProfile,\n      dayTableModel\n    } = props;\n    let isNowIndicator = context.options.nowIndicator;\n    let dayRanges = this.buildDayRanges(dayTableModel, dateProfile, context.dateEnv); // give it the first row of cells\n    // TODO: would move this further down hierarchy, but sliceNowDate needs it\n\n    return createElement(NowTimer, {\n      unit: isNowIndicator ? 'minute' : 'day'\n    }, (nowDate, todayRange) => createElement(TimeCols, Object.assign({\n      ref: this.timeColsRef\n    }, this.slicer.sliceProps(props, dateProfile, null, context, dayRanges), {\n      forPrint: props.forPrint,\n      axis: props.axis,\n      dateProfile: dateProfile,\n      slatMetas: props.slatMetas,\n      slotDuration: props.slotDuration,\n      cells: dayTableModel.cells[0],\n      tableColGroupNode: props.tableColGroupNode,\n      tableMinWidth: props.tableMinWidth,\n      clientWidth: props.clientWidth,\n      clientHeight: props.clientHeight,\n      expandRows: props.expandRows,\n      nowDate: nowDate,\n      nowIndicatorSegs: isNowIndicator && this.slicer.sliceNowDate(nowDate, context, dayRanges),\n      todayRange: todayRange,\n      onScrollTopRequest: props.onScrollTopRequest,\n      onSlatCoords: props.onSlatCoords\n    })));\n  }\n\n}\n\nfunction buildDayRanges(dayTableModel, dateProfile, dateEnv) {\n  let ranges = [];\n\n  for (let date of dayTableModel.headerDates) {\n    ranges.push({\n      start: dateEnv.add(date, dateProfile.slotMinTime),\n      end: dateEnv.add(date, dateProfile.slotMaxTime)\n    });\n  }\n\n  return ranges;\n} // potential nice values for the slot-duration and interval-duration\n// from largest to smallest\n\n\nconst STOCK_SUB_DURATIONS = [{\n  hours: 1\n}, {\n  minutes: 30\n}, {\n  minutes: 15\n}, {\n  seconds: 30\n}, {\n  seconds: 15\n}];\n\nfunction buildSlatMetas(slotMinTime, slotMaxTime, explicitLabelInterval, slotDuration, dateEnv) {\n  let dayStart = new Date(0);\n  let slatTime = slotMinTime;\n  let slatIterator = createDuration(0);\n  let labelInterval = explicitLabelInterval || computeLabelInterval(slotDuration);\n  let metas = [];\n\n  while (asRoughMs(slatTime) < asRoughMs(slotMaxTime)) {\n    let date = dateEnv.add(dayStart, slatTime);\n    let isLabeled = wholeDivideDurations(slatIterator, labelInterval) !== null;\n    metas.push({\n      date,\n      time: slatTime,\n      key: date.toISOString(),\n      isoTimeStr: formatIsoTimeString(date),\n      isLabeled\n    });\n    slatTime = addDurations(slatTime, slotDuration);\n    slatIterator = addDurations(slatIterator, slotDuration);\n  }\n\n  return metas;\n} // Computes an automatic value for slotLabelInterval\n\n\nfunction computeLabelInterval(slotDuration) {\n  let i;\n  let labelInterval;\n  let slotsPerLabel; // find the smallest stock label interval that results in more than one slots-per-label\n\n  for (i = STOCK_SUB_DURATIONS.length - 1; i >= 0; i -= 1) {\n    labelInterval = createDuration(STOCK_SUB_DURATIONS[i]);\n    slotsPerLabel = wholeDivideDurations(labelInterval, slotDuration);\n\n    if (slotsPerLabel !== null && slotsPerLabel > 1) {\n      return labelInterval;\n    }\n  }\n\n  return slotDuration; // fall back\n}\n\nclass DayTimeColsView extends TimeColsView {\n  constructor() {\n    super(...arguments);\n    this.buildTimeColsModel = memoize(buildTimeColsModel);\n    this.buildSlatMetas = memoize(buildSlatMetas);\n  }\n\n  render() {\n    let {\n      options,\n      dateEnv,\n      dateProfileGenerator\n    } = this.context;\n    let {\n      props\n    } = this;\n    let {\n      dateProfile\n    } = props;\n    let dayTableModel = this.buildTimeColsModel(dateProfile, dateProfileGenerator);\n    let splitProps = this.allDaySplitter.splitProps(props);\n    let slatMetas = this.buildSlatMetas(dateProfile.slotMinTime, dateProfile.slotMaxTime, options.slotLabelInterval, options.slotDuration, dateEnv);\n    let {\n      dayMinWidth\n    } = options;\n    let hasAttachedAxis = !dayMinWidth;\n    let hasDetachedAxis = dayMinWidth;\n    let headerContent = options.dayHeaders && createElement(DayHeader, {\n      dates: dayTableModel.headerDates,\n      dateProfile: dateProfile,\n      datesRepDistinctDays: true,\n      renderIntro: hasAttachedAxis ? this.renderHeadAxis : null\n    });\n\n    let allDayContent = options.allDaySlot !== false && (contentArg => createElement(DayTable, Object.assign({}, splitProps.allDay, {\n      dateProfile: dateProfile,\n      dayTableModel: dayTableModel,\n      nextDayThreshold: options.nextDayThreshold,\n      tableMinWidth: contentArg.tableMinWidth,\n      colGroupNode: contentArg.tableColGroupNode,\n      renderRowIntro: hasAttachedAxis ? this.renderTableRowAxis : null,\n      showWeekNumbers: false,\n      expandRows: false,\n      headerAlignElRef: this.headerElRef,\n      clientWidth: contentArg.clientWidth,\n      clientHeight: contentArg.clientHeight,\n      forPrint: props.forPrint\n    }, this.getAllDayMaxEventProps())));\n\n    let timeGridContent = contentArg => createElement(DayTimeCols, Object.assign({}, splitProps.timed, {\n      dayTableModel: dayTableModel,\n      dateProfile: dateProfile,\n      axis: hasAttachedAxis,\n      slotDuration: options.slotDuration,\n      slatMetas: slatMetas,\n      forPrint: props.forPrint,\n      tableColGroupNode: contentArg.tableColGroupNode,\n      tableMinWidth: contentArg.tableMinWidth,\n      clientWidth: contentArg.clientWidth,\n      clientHeight: contentArg.clientHeight,\n      onSlatCoords: this.handleSlatCoords,\n      expandRows: contentArg.expandRows,\n      onScrollTopRequest: this.handleScrollTopRequest\n    }));\n\n    return hasDetachedAxis ? this.renderHScrollLayout(headerContent, allDayContent, timeGridContent, dayTableModel.colCnt, dayMinWidth, slatMetas, this.state.slatCoords) : this.renderSimpleLayout(headerContent, allDayContent, timeGridContent);\n  }\n\n}\n\nfunction buildTimeColsModel(dateProfile, dateProfileGenerator) {\n  let daySeries = new DaySeriesModel(dateProfile.renderRange, dateProfileGenerator);\n  return new DayTableModel(daySeries, false);\n}\n\nexport { DayTimeCols, DayTimeColsSlicer, DayTimeColsView, TimeCols, TimeColsSlatsCoords, TimeColsView, buildDayRanges, buildSlatMetas, buildTimeColsModel };","map":{"version":3,"names":["Splitter","hasBgRendering","createFormatter","ViewContextType","ContentContainer","BaseComponent","DateComponent","diffDays","buildNavLinkAttrs","WeekNumberContainer","getStickyHeaderDates","ViewContainer","SimpleScrollGrid","getStickyFooterScrollbar","NowTimer","NowIndicatorContainer","renderScrollShim","rangeContainsMarker","startOfDay","asRoughMs","createDuration","RefMap","PositionCache","MoreLinkContainer","SegHierarchy","groupIntersectingEntries","binarySearch","getEntrySpanEnd","buildEntryKey","StandardEvent","memoize","sortEventSegs","DayCellContainer","hasCustomDayCellContent","getSegMeta","buildIsoString","computeEarliestSegStart","buildEventRangeKey","BgEvent","renderFill","addDurations","multiplyDuration","wholeDivideDurations","Slicer","intersectRanges","formatIsoTimeString","DayHeader","DaySeriesModel","DayTableModel","createElement","createRef","Fragment","DayTable","AllDaySplitter","getKeyInfo","allDay","timed","getKeysForDateSpan","dateSpan","getKeysForEventDef","eventDef","DEFAULT_SLAT_LABEL_FORMAT","hour","minute","omitZeroMinute","meridiem","TimeColsAxisCell","props","classNames","isLabeled","Consumer","context","className","join","isoTimeStr","dateEnv","options","viewApi","labelFormat","slotLabelFormat","Array","isArray","renderProps","level","time","date","toDate","view","text","format","elTag","elClasses","elAttrs","generatorName","generator","slotLabelContent","renderInnerContent","classNameGenerator","slotLabelClassNames","didMount","slotLabelDidMount","willUnmount","slotLabelWillUnmount","InnerContent","TimeBodyAxis","render","slatMetas","map","slatMeta","key","Object","assign","DEFAULT_WEEK_NUM_FORMAT","week","AUTO_ALL_DAY_MAX_EVENT_ROWS","TimeColsView","constructor","arguments","allDaySplitter","headerElRef","rootElRef","scrollerElRef","state","slatCoords","handleScrollTopRequest","scrollTop","scrollerEl","current","renderHeadAxis","rowKey","frameHeight","dateProfile","range","renderRange","dayCnt","start","end","navLinkAttrs","weekNumbers","defaultFormat","style","height","renderTableRowAxis","rowHeight","allDayText","allDayContent","renderAllDayInner","allDayClassNames","allDayDidMount","allDayWillUnmount","handleSlatCoords","setState","renderSimpleLayout","headerRowContent","timeContent","sections","stickyHeaderDates","push","type","isSticky","chunk","elRef","tableClassName","rowContent","content","outerContent","role","theme","getClass","liquid","expandRows","Boolean","viewSpec","isHeightAuto","forPrint","collapsibleWidth","cols","width","renderHScrollLayout","colCnt","dayMinWidth","ScrollGrid","pluginHooks","scrollGridImpl","Error","stickyFooterScrollbar","syncRowHeights","chunks","arg","rowSyncHeights","contentArg","colSpan","isNowIndicator","nowIndicator","clientHeight","tableColGroupNode","unit","nowDate","nowIndicatorTop","safeComputeTop","elStyle","top","isAxis","colGroups","span","minWidth","getAllDayMaxEventProps","dayMaxEvents","dayMaxEventRows","undefined","TimeColsSlatsCoords","positions","slotDuration","currentRange","startOfDayDate","timeMs","valueOf","slotMinTime","slotMaxTime","computeTimeTop","computeDateTop","when","duration","len","els","length","slatCoverage","milliseconds","slatIndex","slatRemainder","Math","max","min","floor","tops","getHeight","TimeColsSlatsBody","slatElRefs","i","ref","axis","slotLaneContent","slotLaneClassNames","slotLaneDidMount","slotLaneWillUnmount","TimeColsSlats","tableMinWidth","clientWidth","minHeight","componentDidMount","updateSizing","componentDidUpdate","componentWillUnmount","onCoords","rootEl","offsetHeight","collectSlatEls","currentMap","elMap","splitSegsByCol","segs","segsByCol","col","splitInteractionByCol","ui","byRow","affectedInstances","isEvent","seg","TimeColMoreLink","bottom","allDayDate","moreCnt","hiddenSegs","allSegs","extraDateSpan","todayRange","popoverContent","renderPlainFgSegs","defaultGenerator","renderMoreLinkInner","shortText","buildPositioning","segInputs","strictOrder","maxStackCnt","hierarchy","hiddenEntries","addSegs","hiddenGroups","web","buildWeb","stretchWeb","segRects","webToRects","entriesByLevel","buildNode","cacheable","lateral","siblingRange","findNextLevelSegs","nextLevelRes","buildNodes","entry","nextLevelNodes","thickness","lateralStart","lateralEnd","pairs","sort","cmpDescPressures","extractNode","a","b","subjectLevel","subjectLateral","levelCoords","subjectEntry","afterSubject","levelCnt","entries","searchIndex","topLevelNodes","totalThickness","stretchNode","node","startCoord","prevThickness","allThickness","thicknessFraction","endCoord","newChildren","childNode","res","newThickness","rects","processNode","levelCoord","stackDepth","rect","stackForward","processNodes","nodes","keyFunc","workFunc","cache","args","computeSegVCoords","colDate","eventMinHeight","vcoords","spanStart","spanEnd","round","computeFgSegPlacements","segVCoords","eventOrderStrict","eventMaxStack","dumbSegs","index","segPlacements","segRect","dumbSeg","DEFAULT_TIME_FORMAT","TimeColEvent","isShort","defaultTimeFormat","TimeCol","isSelectMirror","selectMirror","mirrorSegs","eventDrag","eventResize","dateSelectionSegs","interactionAffectedInstances","sortedFgSegs","fgEventSegs","eventOrder","extraClassNames","extraDataAttrs","extraRenderProps","renderFillSegs","businessHourSegs","bgEventSegs","renderFgSegs","renderNowIndicator","nowIndicatorSegs","segIsInvisible","isDragging","isResizing","isDateSelecting","renderPositionedFgSegs","eventShortHeight","eventSelection","isMirror","renderHiddenGroups","segPlacement","instanceId","eventRange","instance","isVisible","vStyle","computeSegVStyle","hStyle","computeSegHStyle","left","right","isInset","visibility","isSelected","hiddenGroup","positionCss","compileSegsFromEntries","fillType","children","segHCoords","isRtl","shouldOverlap","slotEventOverlap","nearCoord","farCoord","zIndex","hiddenInstances","segEntries","segEntry","TimeColsContent","splitFgEventSegs","splitBgEventSegs","splitBusinessHourSegs","splitNowIndicatorSegs","splitDateSelectionSegs","splitEventDrag","splitEventResize","cellElRefs","cells","fgEventSegsByRow","bgEventSegsByRow","businessHourSegsByRow","nowIndicatorSegsByRow","dateSelectionSegsByRow","eventDragByRow","eventResizeByRow","cell","updateCoords","onColCoords","collectCellEls","TimeCols","processSlotOptions","handleRootEl","el","registerInteractiveComponent","isHitComboAllowed","unregisterInteractiveComponent","handleScrollRequest","request","onScrollTopRequest","ceil","handleColCoords","colCoords","onSlatCoords","scrollResponder","createScrollResponder","prevProps","update","detach","queryHit","positionLeft","positionTop","snapDuration","snapsPerSlot","colIndex","leftToIndex","topToIndex","slatTop","slatHeight","partial","localSnapIndex","snapIndex","dayDate","add","dayEl","lefts","rights","layer","snapDurationOverride","DayTimeColsSlicer","sliceRange","dayRanges","segRange","isStart","isEnd","DayTimeCols","buildDayRanges","slicer","timeColsRef","dayTableModel","sliceProps","sliceNowDate","ranges","headerDates","STOCK_SUB_DURATIONS","hours","minutes","seconds","buildSlatMetas","explicitLabelInterval","dayStart","Date","slatTime","slatIterator","labelInterval","computeLabelInterval","metas","toISOString","slotsPerLabel","DayTimeColsView","buildTimeColsModel","dateProfileGenerator","splitProps","slotLabelInterval","hasAttachedAxis","hasDetachedAxis","headerContent","dayHeaders","dates","datesRepDistinctDays","renderIntro","allDaySlot","nextDayThreshold","colGroupNode","renderRowIntro","showWeekNumbers","headerAlignElRef","timeGridContent","daySeries"],"sources":["D:/CodingStuff/GitHub/TeaWithColleagues/node_modules/@fullcalendar/timegrid/internal.js"],"sourcesContent":["import { Splitter, hasBgRendering, createFormatter, ViewContextType, ContentContainer, BaseComponent, DateComponent, diffDays, buildNavLinkAttrs, WeekNumberContainer, getStickyHeaderDates, ViewContainer, SimpleScrollGrid, getStickyFooterScrollbar, NowTimer, NowIndicatorContainer, renderScrollShim, rangeContainsMarker, startOfDay, asRoughMs, createDuration, RefMap, PositionCache, MoreLinkContainer, SegHierarchy, groupIntersectingEntries, binarySearch, getEntrySpanEnd, buildEntryKey, StandardEvent, memoize, sortEventSegs, DayCellContainer, hasCustomDayCellContent, getSegMeta, buildIsoString, computeEarliestSegStart, buildEventRangeKey, BgEvent, renderFill, addDurations, multiplyDuration, wholeDivideDurations, Slicer, intersectRanges, formatIsoTimeString, DayHeader, DaySeriesModel, DayTableModel } from '@fullcalendar/core/internal.js';\nimport { createElement, createRef, Fragment } from '@fullcalendar/core/preact.js';\nimport { DayTable } from '@fullcalendar/daygrid/internal.js';\n\nclass AllDaySplitter extends Splitter {\n    getKeyInfo() {\n        return {\n            allDay: {},\n            timed: {},\n        };\n    }\n    getKeysForDateSpan(dateSpan) {\n        if (dateSpan.allDay) {\n            return ['allDay'];\n        }\n        return ['timed'];\n    }\n    getKeysForEventDef(eventDef) {\n        if (!eventDef.allDay) {\n            return ['timed'];\n        }\n        if (hasBgRendering(eventDef)) {\n            return ['timed', 'allDay'];\n        }\n        return ['allDay'];\n    }\n}\n\nconst DEFAULT_SLAT_LABEL_FORMAT = createFormatter({\n    hour: 'numeric',\n    minute: '2-digit',\n    omitZeroMinute: true,\n    meridiem: 'short',\n});\nfunction TimeColsAxisCell(props) {\n    let classNames = [\n        'fc-timegrid-slot',\n        'fc-timegrid-slot-label',\n        props.isLabeled ? 'fc-scrollgrid-shrink' : 'fc-timegrid-slot-minor',\n    ];\n    return (createElement(ViewContextType.Consumer, null, (context) => {\n        if (!props.isLabeled) {\n            return (createElement(\"td\", { className: classNames.join(' '), \"data-time\": props.isoTimeStr }));\n        }\n        let { dateEnv, options, viewApi } = context;\n        let labelFormat = // TODO: fully pre-parse\n         options.slotLabelFormat == null ? DEFAULT_SLAT_LABEL_FORMAT :\n            Array.isArray(options.slotLabelFormat) ? createFormatter(options.slotLabelFormat[0]) :\n                createFormatter(options.slotLabelFormat);\n        let renderProps = {\n            level: 0,\n            time: props.time,\n            date: dateEnv.toDate(props.date),\n            view: viewApi,\n            text: dateEnv.format(props.date, labelFormat),\n        };\n        return (createElement(ContentContainer, { elTag: \"td\", elClasses: classNames, elAttrs: {\n                'data-time': props.isoTimeStr,\n            }, renderProps: renderProps, generatorName: \"slotLabelContent\", generator: options.slotLabelContent || renderInnerContent, classNameGenerator: options.slotLabelClassNames, didMount: options.slotLabelDidMount, willUnmount: options.slotLabelWillUnmount }, (InnerContent) => (createElement(\"div\", { className: \"fc-timegrid-slot-label-frame fc-scrollgrid-shrink-frame\" },\n            createElement(InnerContent, { elTag: \"div\", elClasses: [\n                    'fc-timegrid-slot-label-cushion',\n                    'fc-scrollgrid-shrink-cushion',\n                ] })))));\n    }));\n}\nfunction renderInnerContent(props) {\n    return props.text;\n}\n\nclass TimeBodyAxis extends BaseComponent {\n    render() {\n        return this.props.slatMetas.map((slatMeta) => (createElement(\"tr\", { key: slatMeta.key },\n            createElement(TimeColsAxisCell, Object.assign({}, slatMeta)))));\n    }\n}\n\nconst DEFAULT_WEEK_NUM_FORMAT = createFormatter({ week: 'short' });\nconst AUTO_ALL_DAY_MAX_EVENT_ROWS = 5;\nclass TimeColsView extends DateComponent {\n    constructor() {\n        super(...arguments);\n        this.allDaySplitter = new AllDaySplitter(); // for use by subclasses\n        this.headerElRef = createRef();\n        this.rootElRef = createRef();\n        this.scrollerElRef = createRef();\n        this.state = {\n            slatCoords: null,\n        };\n        this.handleScrollTopRequest = (scrollTop) => {\n            let scrollerEl = this.scrollerElRef.current;\n            if (scrollerEl) { // TODO: not sure how this could ever be null. weirdness with the reducer\n                scrollerEl.scrollTop = scrollTop;\n            }\n        };\n        /* Header Render Methods\n        ------------------------------------------------------------------------------------------------------------------*/\n        this.renderHeadAxis = (rowKey, frameHeight = '') => {\n            let { options } = this.context;\n            let { dateProfile } = this.props;\n            let range = dateProfile.renderRange;\n            let dayCnt = diffDays(range.start, range.end);\n            // only do in day views (to avoid doing in week views that dont need it)\n            let navLinkAttrs = (dayCnt === 1)\n                ? buildNavLinkAttrs(this.context, range.start, 'week')\n                : {};\n            if (options.weekNumbers && rowKey === 'day') {\n                return (createElement(WeekNumberContainer, { elTag: \"th\", elClasses: [\n                        'fc-timegrid-axis',\n                        'fc-scrollgrid-shrink',\n                    ], elAttrs: {\n                        'aria-hidden': true,\n                    }, date: range.start, defaultFormat: DEFAULT_WEEK_NUM_FORMAT }, (InnerContent) => (createElement(\"div\", { className: [\n                        'fc-timegrid-axis-frame',\n                        'fc-scrollgrid-shrink-frame',\n                        'fc-timegrid-axis-frame-liquid',\n                    ].join(' '), style: { height: frameHeight } },\n                    createElement(InnerContent, { elTag: \"a\", elClasses: [\n                            'fc-timegrid-axis-cushion',\n                            'fc-scrollgrid-shrink-cushion',\n                            'fc-scrollgrid-sync-inner',\n                        ], elAttrs: navLinkAttrs })))));\n            }\n            return (createElement(\"th\", { \"aria-hidden\": true, className: \"fc-timegrid-axis\" },\n                createElement(\"div\", { className: \"fc-timegrid-axis-frame\", style: { height: frameHeight } })));\n        };\n        /* Table Component Render Methods\n        ------------------------------------------------------------------------------------------------------------------*/\n        // only a one-way height sync. we don't send the axis inner-content height to the DayGrid,\n        // but DayGrid still needs to have classNames on inner elements in order to measure.\n        this.renderTableRowAxis = (rowHeight) => {\n            let { options, viewApi } = this.context;\n            let renderProps = {\n                text: options.allDayText,\n                view: viewApi,\n            };\n            return (\n            // TODO: make reusable hook. used in list view too\n            createElement(ContentContainer, { elTag: \"td\", elClasses: [\n                    'fc-timegrid-axis',\n                    'fc-scrollgrid-shrink',\n                ], elAttrs: {\n                    'aria-hidden': true,\n                }, renderProps: renderProps, generatorName: \"allDayContent\", generator: options.allDayContent || renderAllDayInner, classNameGenerator: options.allDayClassNames, didMount: options.allDayDidMount, willUnmount: options.allDayWillUnmount }, (InnerContent) => (createElement(\"div\", { className: [\n                    'fc-timegrid-axis-frame',\n                    'fc-scrollgrid-shrink-frame',\n                    rowHeight == null ? ' fc-timegrid-axis-frame-liquid' : '',\n                ].join(' '), style: { height: rowHeight } },\n                createElement(InnerContent, { elTag: \"span\", elClasses: [\n                        'fc-timegrid-axis-cushion',\n                        'fc-scrollgrid-shrink-cushion',\n                        'fc-scrollgrid-sync-inner',\n                    ] })))));\n        };\n        this.handleSlatCoords = (slatCoords) => {\n            this.setState({ slatCoords });\n        };\n    }\n    // rendering\n    // ----------------------------------------------------------------------------------------------------\n    renderSimpleLayout(headerRowContent, allDayContent, timeContent) {\n        let { context, props } = this;\n        let sections = [];\n        let stickyHeaderDates = getStickyHeaderDates(context.options);\n        if (headerRowContent) {\n            sections.push({\n                type: 'header',\n                key: 'header',\n                isSticky: stickyHeaderDates,\n                chunk: {\n                    elRef: this.headerElRef,\n                    tableClassName: 'fc-col-header',\n                    rowContent: headerRowContent,\n                },\n            });\n        }\n        if (allDayContent) {\n            sections.push({\n                type: 'body',\n                key: 'all-day',\n                chunk: { content: allDayContent },\n            });\n            sections.push({\n                type: 'body',\n                key: 'all-day-divider',\n                outerContent: ( // TODO: rename to cellContent so don't need to define <tr>?\n                createElement(\"tr\", { role: \"presentation\", className: \"fc-scrollgrid-section\" },\n                    createElement(\"td\", { className: 'fc-timegrid-divider ' + context.theme.getClass('tableCellShaded') }))),\n            });\n        }\n        sections.push({\n            type: 'body',\n            key: 'body',\n            liquid: true,\n            expandRows: Boolean(context.options.expandRows),\n            chunk: {\n                scrollerElRef: this.scrollerElRef,\n                content: timeContent,\n            },\n        });\n        return (createElement(ViewContainer, { elRef: this.rootElRef, elClasses: ['fc-timegrid'], viewSpec: context.viewSpec },\n            createElement(SimpleScrollGrid, { liquid: !props.isHeightAuto && !props.forPrint, collapsibleWidth: props.forPrint, cols: [{ width: 'shrink' }], sections: sections })));\n    }\n    renderHScrollLayout(headerRowContent, allDayContent, timeContent, colCnt, dayMinWidth, slatMetas, slatCoords) {\n        let ScrollGrid = this.context.pluginHooks.scrollGridImpl;\n        if (!ScrollGrid) {\n            throw new Error('No ScrollGrid implementation');\n        }\n        let { context, props } = this;\n        let stickyHeaderDates = !props.forPrint && getStickyHeaderDates(context.options);\n        let stickyFooterScrollbar = !props.forPrint && getStickyFooterScrollbar(context.options);\n        let sections = [];\n        if (headerRowContent) {\n            sections.push({\n                type: 'header',\n                key: 'header',\n                isSticky: stickyHeaderDates,\n                syncRowHeights: true,\n                chunks: [\n                    {\n                        key: 'axis',\n                        rowContent: (arg) => (createElement(\"tr\", { role: \"presentation\" }, this.renderHeadAxis('day', arg.rowSyncHeights[0]))),\n                    },\n                    {\n                        key: 'cols',\n                        elRef: this.headerElRef,\n                        tableClassName: 'fc-col-header',\n                        rowContent: headerRowContent,\n                    },\n                ],\n            });\n        }\n        if (allDayContent) {\n            sections.push({\n                type: 'body',\n                key: 'all-day',\n                syncRowHeights: true,\n                chunks: [\n                    {\n                        key: 'axis',\n                        rowContent: (contentArg) => (createElement(\"tr\", { role: \"presentation\" }, this.renderTableRowAxis(contentArg.rowSyncHeights[0]))),\n                    },\n                    {\n                        key: 'cols',\n                        content: allDayContent,\n                    },\n                ],\n            });\n            sections.push({\n                key: 'all-day-divider',\n                type: 'body',\n                outerContent: ( // TODO: rename to cellContent so don't need to define <tr>?\n                createElement(\"tr\", { role: \"presentation\", className: \"fc-scrollgrid-section\" },\n                    createElement(\"td\", { colSpan: 2, className: 'fc-timegrid-divider ' + context.theme.getClass('tableCellShaded') }))),\n            });\n        }\n        let isNowIndicator = context.options.nowIndicator;\n        sections.push({\n            type: 'body',\n            key: 'body',\n            liquid: true,\n            expandRows: Boolean(context.options.expandRows),\n            chunks: [\n                {\n                    key: 'axis',\n                    content: (arg) => (\n                    // TODO: make this now-indicator arrow more DRY with TimeColsContent\n                    createElement(\"div\", { className: \"fc-timegrid-axis-chunk\" },\n                        createElement(\"table\", { \"aria-hidden\": true, style: { height: arg.expandRows ? arg.clientHeight : '' } },\n                            arg.tableColGroupNode,\n                            createElement(\"tbody\", null,\n                                createElement(TimeBodyAxis, { slatMetas: slatMetas }))),\n                        createElement(\"div\", { className: \"fc-timegrid-now-indicator-container\" },\n                            createElement(NowTimer, { unit: isNowIndicator ? 'minute' : 'day' /* hacky */ }, (nowDate) => {\n                                let nowIndicatorTop = isNowIndicator &&\n                                    slatCoords &&\n                                    slatCoords.safeComputeTop(nowDate); // might return void\n                                if (typeof nowIndicatorTop === 'number') {\n                                    return (createElement(NowIndicatorContainer, { elClasses: ['fc-timegrid-now-indicator-arrow'], elStyle: { top: nowIndicatorTop }, isAxis: true, date: nowDate }));\n                                }\n                                return null;\n                            })))),\n                },\n                {\n                    key: 'cols',\n                    scrollerElRef: this.scrollerElRef,\n                    content: timeContent,\n                },\n            ],\n        });\n        if (stickyFooterScrollbar) {\n            sections.push({\n                key: 'footer',\n                type: 'footer',\n                isSticky: true,\n                chunks: [\n                    {\n                        key: 'axis',\n                        content: renderScrollShim,\n                    },\n                    {\n                        key: 'cols',\n                        content: renderScrollShim,\n                    },\n                ],\n            });\n        }\n        return (createElement(ViewContainer, { elRef: this.rootElRef, elClasses: ['fc-timegrid'], viewSpec: context.viewSpec },\n            createElement(ScrollGrid, { liquid: !props.isHeightAuto && !props.forPrint, collapsibleWidth: false, colGroups: [\n                    { width: 'shrink', cols: [{ width: 'shrink' }] },\n                    { cols: [{ span: colCnt, minWidth: dayMinWidth }] },\n                ], sections: sections })));\n    }\n    /* Dimensions\n    ------------------------------------------------------------------------------------------------------------------*/\n    getAllDayMaxEventProps() {\n        let { dayMaxEvents, dayMaxEventRows } = this.context.options;\n        if (dayMaxEvents === true || dayMaxEventRows === true) { // is auto?\n            dayMaxEvents = undefined;\n            dayMaxEventRows = AUTO_ALL_DAY_MAX_EVENT_ROWS; // make sure \"auto\" goes to a real number\n        }\n        return { dayMaxEvents, dayMaxEventRows };\n    }\n}\nfunction renderAllDayInner(renderProps) {\n    return renderProps.text;\n}\n\nclass TimeColsSlatsCoords {\n    constructor(positions, dateProfile, slotDuration) {\n        this.positions = positions;\n        this.dateProfile = dateProfile;\n        this.slotDuration = slotDuration;\n    }\n    safeComputeTop(date) {\n        let { dateProfile } = this;\n        if (rangeContainsMarker(dateProfile.currentRange, date)) {\n            let startOfDayDate = startOfDay(date);\n            let timeMs = date.valueOf() - startOfDayDate.valueOf();\n            if (timeMs >= asRoughMs(dateProfile.slotMinTime) &&\n                timeMs < asRoughMs(dateProfile.slotMaxTime)) {\n                return this.computeTimeTop(createDuration(timeMs));\n            }\n        }\n        return null;\n    }\n    // Computes the top coordinate, relative to the bounds of the grid, of the given date.\n    // A `startOfDayDate` must be given for avoiding ambiguity over how to treat midnight.\n    computeDateTop(when, startOfDayDate) {\n        if (!startOfDayDate) {\n            startOfDayDate = startOfDay(when);\n        }\n        return this.computeTimeTop(createDuration(when.valueOf() - startOfDayDate.valueOf()));\n    }\n    // Computes the top coordinate, relative to the bounds of the grid, of the given time (a Duration).\n    // This is a makeshify way to compute the time-top. Assumes all slatMetas dates are uniform.\n    // Eventually allow computation with arbirary slat dates.\n    computeTimeTop(duration) {\n        let { positions, dateProfile } = this;\n        let len = positions.els.length;\n        // floating-point value of # of slots covered\n        let slatCoverage = (duration.milliseconds - asRoughMs(dateProfile.slotMinTime)) / asRoughMs(this.slotDuration);\n        let slatIndex;\n        let slatRemainder;\n        // compute a floating-point number for how many slats should be progressed through.\n        // from 0 to number of slats (inclusive)\n        // constrained because slotMinTime/slotMaxTime might be customized.\n        slatCoverage = Math.max(0, slatCoverage);\n        slatCoverage = Math.min(len, slatCoverage);\n        // an integer index of the furthest whole slat\n        // from 0 to number slats (*exclusive*, so len-1)\n        slatIndex = Math.floor(slatCoverage);\n        slatIndex = Math.min(slatIndex, len - 1);\n        // how much further through the slatIndex slat (from 0.0-1.0) must be covered in addition.\n        // could be 1.0 if slatCoverage is covering *all* the slots\n        slatRemainder = slatCoverage - slatIndex;\n        return positions.tops[slatIndex] +\n            positions.getHeight(slatIndex) * slatRemainder;\n    }\n}\n\nclass TimeColsSlatsBody extends BaseComponent {\n    render() {\n        let { props, context } = this;\n        let { options } = context;\n        let { slatElRefs } = props;\n        return (createElement(\"tbody\", null, props.slatMetas.map((slatMeta, i) => {\n            let renderProps = {\n                time: slatMeta.time,\n                date: context.dateEnv.toDate(slatMeta.date),\n                view: context.viewApi,\n            };\n            return (createElement(\"tr\", { key: slatMeta.key, ref: slatElRefs.createRef(slatMeta.key) },\n                props.axis && (createElement(TimeColsAxisCell, Object.assign({}, slatMeta))),\n                createElement(ContentContainer, { elTag: \"td\", elClasses: [\n                        'fc-timegrid-slot',\n                        'fc-timegrid-slot-lane',\n                        !slatMeta.isLabeled && 'fc-timegrid-slot-minor',\n                    ], elAttrs: {\n                        'data-time': slatMeta.isoTimeStr,\n                    }, renderProps: renderProps, generatorName: \"slotLaneContent\", generator: options.slotLaneContent, classNameGenerator: options.slotLaneClassNames, didMount: options.slotLaneDidMount, willUnmount: options.slotLaneWillUnmount })));\n        })));\n    }\n}\n\n/*\nfor the horizontal \"slats\" that run width-wise. Has a time axis on a side. Depends on RTL.\n*/\nclass TimeColsSlats extends BaseComponent {\n    constructor() {\n        super(...arguments);\n        this.rootElRef = createRef();\n        this.slatElRefs = new RefMap();\n    }\n    render() {\n        let { props, context } = this;\n        return (createElement(\"div\", { ref: this.rootElRef, className: \"fc-timegrid-slots\" },\n            createElement(\"table\", { \"aria-hidden\": true, className: context.theme.getClass('table'), style: {\n                    minWidth: props.tableMinWidth,\n                    width: props.clientWidth,\n                    height: props.minHeight,\n                } },\n                props.tableColGroupNode /* relies on there only being a single <col> for the axis */,\n                createElement(TimeColsSlatsBody, { slatElRefs: this.slatElRefs, axis: props.axis, slatMetas: props.slatMetas }))));\n    }\n    componentDidMount() {\n        this.updateSizing();\n    }\n    componentDidUpdate() {\n        this.updateSizing();\n    }\n    componentWillUnmount() {\n        if (this.props.onCoords) {\n            this.props.onCoords(null);\n        }\n    }\n    updateSizing() {\n        let { context, props } = this;\n        if (props.onCoords &&\n            props.clientWidth !== null // means sizing has stabilized\n        ) {\n            let rootEl = this.rootElRef.current;\n            if (rootEl.offsetHeight) { // not hidden by css\n                props.onCoords(new TimeColsSlatsCoords(new PositionCache(this.rootElRef.current, collectSlatEls(this.slatElRefs.currentMap, props.slatMetas), false, true), this.props.dateProfile, context.options.slotDuration));\n            }\n        }\n    }\n}\nfunction collectSlatEls(elMap, slatMetas) {\n    return slatMetas.map((slatMeta) => elMap[slatMeta.key]);\n}\n\nfunction splitSegsByCol(segs, colCnt) {\n    let segsByCol = [];\n    let i;\n    for (i = 0; i < colCnt; i += 1) {\n        segsByCol.push([]);\n    }\n    if (segs) {\n        for (i = 0; i < segs.length; i += 1) {\n            segsByCol[segs[i].col].push(segs[i]);\n        }\n    }\n    return segsByCol;\n}\nfunction splitInteractionByCol(ui, colCnt) {\n    let byRow = [];\n    if (!ui) {\n        for (let i = 0; i < colCnt; i += 1) {\n            byRow[i] = null;\n        }\n    }\n    else {\n        for (let i = 0; i < colCnt; i += 1) {\n            byRow[i] = {\n                affectedInstances: ui.affectedInstances,\n                isEvent: ui.isEvent,\n                segs: [],\n            };\n        }\n        for (let seg of ui.segs) {\n            byRow[seg.col].segs.push(seg);\n        }\n    }\n    return byRow;\n}\n\nclass TimeColMoreLink extends BaseComponent {\n    render() {\n        let { props } = this;\n        return (createElement(MoreLinkContainer, { elClasses: ['fc-timegrid-more-link'], elStyle: {\n                top: props.top,\n                bottom: props.bottom,\n            }, allDayDate: null, moreCnt: props.hiddenSegs.length, allSegs: props.hiddenSegs, hiddenSegs: props.hiddenSegs, extraDateSpan: props.extraDateSpan, dateProfile: props.dateProfile, todayRange: props.todayRange, popoverContent: () => renderPlainFgSegs(props.hiddenSegs, props), defaultGenerator: renderMoreLinkInner }, (InnerContent) => (createElement(InnerContent, { elTag: \"div\", elClasses: ['fc-timegrid-more-link-inner', 'fc-sticky'] }))));\n    }\n}\nfunction renderMoreLinkInner(props) {\n    return props.shortText;\n}\n\n// segInputs assumed sorted\nfunction buildPositioning(segInputs, strictOrder, maxStackCnt) {\n    let hierarchy = new SegHierarchy();\n    if (strictOrder != null) {\n        hierarchy.strictOrder = strictOrder;\n    }\n    if (maxStackCnt != null) {\n        hierarchy.maxStackCnt = maxStackCnt;\n    }\n    let hiddenEntries = hierarchy.addSegs(segInputs);\n    let hiddenGroups = groupIntersectingEntries(hiddenEntries);\n    let web = buildWeb(hierarchy);\n    web = stretchWeb(web, 1); // all levelCoords/thickness will have 0.0-1.0\n    let segRects = webToRects(web);\n    return { segRects, hiddenGroups };\n}\nfunction buildWeb(hierarchy) {\n    const { entriesByLevel } = hierarchy;\n    const buildNode = cacheable((level, lateral) => level + ':' + lateral, (level, lateral) => {\n        let siblingRange = findNextLevelSegs(hierarchy, level, lateral);\n        let nextLevelRes = buildNodes(siblingRange, buildNode);\n        let entry = entriesByLevel[level][lateral];\n        return [\n            Object.assign(Object.assign({}, entry), { nextLevelNodes: nextLevelRes[0] }),\n            entry.thickness + nextLevelRes[1], // the pressure builds\n        ];\n    });\n    return buildNodes(entriesByLevel.length\n        ? { level: 0, lateralStart: 0, lateralEnd: entriesByLevel[0].length }\n        : null, buildNode)[0];\n}\nfunction buildNodes(siblingRange, buildNode) {\n    if (!siblingRange) {\n        return [[], 0];\n    }\n    let { level, lateralStart, lateralEnd } = siblingRange;\n    let lateral = lateralStart;\n    let pairs = [];\n    while (lateral < lateralEnd) {\n        pairs.push(buildNode(level, lateral));\n        lateral += 1;\n    }\n    pairs.sort(cmpDescPressures);\n    return [\n        pairs.map(extractNode),\n        pairs[0][1], // first item's pressure\n    ];\n}\nfunction cmpDescPressures(a, b) {\n    return b[1] - a[1];\n}\nfunction extractNode(a) {\n    return a[0];\n}\nfunction findNextLevelSegs(hierarchy, subjectLevel, subjectLateral) {\n    let { levelCoords, entriesByLevel } = hierarchy;\n    let subjectEntry = entriesByLevel[subjectLevel][subjectLateral];\n    let afterSubject = levelCoords[subjectLevel] + subjectEntry.thickness;\n    let levelCnt = levelCoords.length;\n    let level = subjectLevel;\n    // skip past levels that are too high up\n    for (; level < levelCnt && levelCoords[level] < afterSubject; level += 1)\n        ; // do nothing\n    for (; level < levelCnt; level += 1) {\n        let entries = entriesByLevel[level];\n        let entry;\n        let searchIndex = binarySearch(entries, subjectEntry.span.start, getEntrySpanEnd);\n        let lateralStart = searchIndex[0] + searchIndex[1]; // if exact match (which doesn't collide), go to next one\n        let lateralEnd = lateralStart;\n        while ( // loop through entries that horizontally intersect\n        (entry = entries[lateralEnd]) && // but not past the whole seg list\n            entry.span.start < subjectEntry.span.end) {\n            lateralEnd += 1;\n        }\n        if (lateralStart < lateralEnd) {\n            return { level, lateralStart, lateralEnd };\n        }\n    }\n    return null;\n}\nfunction stretchWeb(topLevelNodes, totalThickness) {\n    const stretchNode = cacheable((node, startCoord, prevThickness) => buildEntryKey(node), (node, startCoord, prevThickness) => {\n        let { nextLevelNodes, thickness } = node;\n        let allThickness = thickness + prevThickness;\n        let thicknessFraction = thickness / allThickness;\n        let endCoord;\n        let newChildren = [];\n        if (!nextLevelNodes.length) {\n            endCoord = totalThickness;\n        }\n        else {\n            for (let childNode of nextLevelNodes) {\n                if (endCoord === undefined) {\n                    let res = stretchNode(childNode, startCoord, allThickness);\n                    endCoord = res[0];\n                    newChildren.push(res[1]);\n                }\n                else {\n                    let res = stretchNode(childNode, endCoord, 0);\n                    newChildren.push(res[1]);\n                }\n            }\n        }\n        let newThickness = (endCoord - startCoord) * thicknessFraction;\n        return [endCoord - newThickness, Object.assign(Object.assign({}, node), { thickness: newThickness, nextLevelNodes: newChildren })];\n    });\n    return topLevelNodes.map((node) => stretchNode(node, 0, 0)[1]);\n}\n// not sorted in any particular order\nfunction webToRects(topLevelNodes) {\n    let rects = [];\n    const processNode = cacheable((node, levelCoord, stackDepth) => buildEntryKey(node), (node, levelCoord, stackDepth) => {\n        let rect = Object.assign(Object.assign({}, node), { levelCoord,\n            stackDepth, stackForward: 0 });\n        rects.push(rect);\n        return (rect.stackForward = processNodes(node.nextLevelNodes, levelCoord + node.thickness, stackDepth + 1) + 1);\n    });\n    function processNodes(nodes, levelCoord, stackDepth) {\n        let stackForward = 0;\n        for (let node of nodes) {\n            stackForward = Math.max(processNode(node, levelCoord, stackDepth), stackForward);\n        }\n        return stackForward;\n    }\n    processNodes(topLevelNodes, 0, 0);\n    return rects; // TODO: sort rects by levelCoord to be consistent with toRects?\n}\n// TODO: move to general util\nfunction cacheable(keyFunc, workFunc) {\n    const cache = {};\n    return (...args) => {\n        let key = keyFunc(...args);\n        return (key in cache)\n            ? cache[key]\n            : (cache[key] = workFunc(...args));\n    };\n}\n\nfunction computeSegVCoords(segs, colDate, slatCoords = null, eventMinHeight = 0) {\n    let vcoords = [];\n    if (slatCoords) {\n        for (let i = 0; i < segs.length; i += 1) {\n            let seg = segs[i];\n            let spanStart = slatCoords.computeDateTop(seg.start, colDate);\n            let spanEnd = Math.max(spanStart + (eventMinHeight || 0), // :(\n            slatCoords.computeDateTop(seg.end, colDate));\n            vcoords.push({\n                start: Math.round(spanStart),\n                end: Math.round(spanEnd), //\n            });\n        }\n    }\n    return vcoords;\n}\nfunction computeFgSegPlacements(segs, segVCoords, // might not have for every seg\neventOrderStrict, eventMaxStack) {\n    let segInputs = [];\n    let dumbSegs = []; // segs without coords\n    for (let i = 0; i < segs.length; i += 1) {\n        let vcoords = segVCoords[i];\n        if (vcoords) {\n            segInputs.push({\n                index: i,\n                thickness: 1,\n                span: vcoords,\n            });\n        }\n        else {\n            dumbSegs.push(segs[i]);\n        }\n    }\n    let { segRects, hiddenGroups } = buildPositioning(segInputs, eventOrderStrict, eventMaxStack);\n    let segPlacements = [];\n    for (let segRect of segRects) {\n        segPlacements.push({\n            seg: segs[segRect.index],\n            rect: segRect,\n        });\n    }\n    for (let dumbSeg of dumbSegs) {\n        segPlacements.push({ seg: dumbSeg, rect: null });\n    }\n    return { segPlacements, hiddenGroups };\n}\n\nconst DEFAULT_TIME_FORMAT = createFormatter({\n    hour: 'numeric',\n    minute: '2-digit',\n    meridiem: false,\n});\nclass TimeColEvent extends BaseComponent {\n    render() {\n        return (createElement(StandardEvent, Object.assign({}, this.props, { elClasses: [\n                'fc-timegrid-event',\n                'fc-v-event',\n                this.props.isShort && 'fc-timegrid-event-short',\n            ], defaultTimeFormat: DEFAULT_TIME_FORMAT })));\n    }\n}\n\nclass TimeCol extends BaseComponent {\n    constructor() {\n        super(...arguments);\n        this.sortEventSegs = memoize(sortEventSegs);\n    }\n    // TODO: memoize event-placement?\n    render() {\n        let { props, context } = this;\n        let { options } = context;\n        let isSelectMirror = options.selectMirror;\n        let mirrorSegs = // yuck\n         (props.eventDrag && props.eventDrag.segs) ||\n            (props.eventResize && props.eventResize.segs) ||\n            (isSelectMirror && props.dateSelectionSegs) ||\n            [];\n        let interactionAffectedInstances = // TODO: messy way to compute this\n         (props.eventDrag && props.eventDrag.affectedInstances) ||\n            (props.eventResize && props.eventResize.affectedInstances) ||\n            {};\n        let sortedFgSegs = this.sortEventSegs(props.fgEventSegs, options.eventOrder);\n        return (createElement(DayCellContainer, { elTag: \"td\", elRef: props.elRef, elClasses: [\n                'fc-timegrid-col',\n                ...(props.extraClassNames || []),\n            ], elAttrs: Object.assign({ role: 'gridcell' }, props.extraDataAttrs), date: props.date, dateProfile: props.dateProfile, todayRange: props.todayRange, extraRenderProps: props.extraRenderProps }, (InnerContent) => (createElement(\"div\", { className: \"fc-timegrid-col-frame\" },\n            createElement(\"div\", { className: \"fc-timegrid-col-bg\" },\n                this.renderFillSegs(props.businessHourSegs, 'non-business'),\n                this.renderFillSegs(props.bgEventSegs, 'bg-event'),\n                this.renderFillSegs(props.dateSelectionSegs, 'highlight')),\n            createElement(\"div\", { className: \"fc-timegrid-col-events\" }, this.renderFgSegs(sortedFgSegs, interactionAffectedInstances, false, false, false)),\n            createElement(\"div\", { className: \"fc-timegrid-col-events\" }, this.renderFgSegs(mirrorSegs, {}, Boolean(props.eventDrag), Boolean(props.eventResize), Boolean(isSelectMirror))),\n            createElement(\"div\", { className: \"fc-timegrid-now-indicator-container\" }, this.renderNowIndicator(props.nowIndicatorSegs)),\n            hasCustomDayCellContent(options) && (createElement(InnerContent, { elTag: \"div\", elClasses: ['fc-timegrid-col-misc'] }))))));\n    }\n    renderFgSegs(sortedFgSegs, segIsInvisible, isDragging, isResizing, isDateSelecting) {\n        let { props } = this;\n        if (props.forPrint) {\n            return renderPlainFgSegs(sortedFgSegs, props);\n        }\n        return this.renderPositionedFgSegs(sortedFgSegs, segIsInvisible, isDragging, isResizing, isDateSelecting);\n    }\n    renderPositionedFgSegs(segs, // if not mirror, needs to be sorted\n    segIsInvisible, isDragging, isResizing, isDateSelecting) {\n        let { eventMaxStack, eventShortHeight, eventOrderStrict, eventMinHeight } = this.context.options;\n        let { date, slatCoords, eventSelection, todayRange, nowDate } = this.props;\n        let isMirror = isDragging || isResizing || isDateSelecting;\n        let segVCoords = computeSegVCoords(segs, date, slatCoords, eventMinHeight);\n        let { segPlacements, hiddenGroups } = computeFgSegPlacements(segs, segVCoords, eventOrderStrict, eventMaxStack);\n        return (createElement(Fragment, null,\n            this.renderHiddenGroups(hiddenGroups, segs),\n            segPlacements.map((segPlacement) => {\n                let { seg, rect } = segPlacement;\n                let instanceId = seg.eventRange.instance.instanceId;\n                let isVisible = isMirror || Boolean(!segIsInvisible[instanceId] && rect);\n                let vStyle = computeSegVStyle(rect && rect.span);\n                let hStyle = (!isMirror && rect) ? this.computeSegHStyle(rect) : { left: 0, right: 0 };\n                let isInset = Boolean(rect) && rect.stackForward > 0;\n                let isShort = Boolean(rect) && (rect.span.end - rect.span.start) < eventShortHeight; // look at other places for this problem\n                return (createElement(\"div\", { className: 'fc-timegrid-event-harness' +\n                        (isInset ? ' fc-timegrid-event-harness-inset' : ''), key: instanceId, style: Object.assign(Object.assign({ visibility: isVisible ? '' : 'hidden' }, vStyle), hStyle) },\n                    createElement(TimeColEvent, Object.assign({ seg: seg, isDragging: isDragging, isResizing: isResizing, isDateSelecting: isDateSelecting, isSelected: instanceId === eventSelection, isShort: isShort }, getSegMeta(seg, todayRange, nowDate)))));\n            })));\n    }\n    // will already have eventMinHeight applied because segInputs already had it\n    renderHiddenGroups(hiddenGroups, segs) {\n        let { extraDateSpan, dateProfile, todayRange, nowDate, eventSelection, eventDrag, eventResize } = this.props;\n        return (createElement(Fragment, null, hiddenGroups.map((hiddenGroup) => {\n            let positionCss = computeSegVStyle(hiddenGroup.span);\n            let hiddenSegs = compileSegsFromEntries(hiddenGroup.entries, segs);\n            return (createElement(TimeColMoreLink, { key: buildIsoString(computeEarliestSegStart(hiddenSegs)), hiddenSegs: hiddenSegs, top: positionCss.top, bottom: positionCss.bottom, extraDateSpan: extraDateSpan, dateProfile: dateProfile, todayRange: todayRange, nowDate: nowDate, eventSelection: eventSelection, eventDrag: eventDrag, eventResize: eventResize }));\n        })));\n    }\n    renderFillSegs(segs, fillType) {\n        let { props, context } = this;\n        let segVCoords = computeSegVCoords(segs, props.date, props.slatCoords, context.options.eventMinHeight); // don't assume all populated\n        let children = segVCoords.map((vcoords, i) => {\n            let seg = segs[i];\n            return (createElement(\"div\", { key: buildEventRangeKey(seg.eventRange), className: \"fc-timegrid-bg-harness\", style: computeSegVStyle(vcoords) }, fillType === 'bg-event' ?\n                createElement(BgEvent, Object.assign({ seg: seg }, getSegMeta(seg, props.todayRange, props.nowDate))) :\n                renderFill(fillType)));\n        });\n        return createElement(Fragment, null, children);\n    }\n    renderNowIndicator(segs) {\n        let { slatCoords, date } = this.props;\n        if (!slatCoords) {\n            return null;\n        }\n        return segs.map((seg, i) => (createElement(NowIndicatorContainer\n        // key doesn't matter. will only ever be one\n        , { \n            // key doesn't matter. will only ever be one\n            key: i, elClasses: ['fc-timegrid-now-indicator-line'], elStyle: {\n                top: slatCoords.computeDateTop(seg.start, date),\n            }, isAxis: false, date: date })));\n    }\n    computeSegHStyle(segHCoords) {\n        let { isRtl, options } = this.context;\n        let shouldOverlap = options.slotEventOverlap;\n        let nearCoord = segHCoords.levelCoord; // the left side if LTR. the right side if RTL. floating-point\n        let farCoord = segHCoords.levelCoord + segHCoords.thickness; // the right side if LTR. the left side if RTL. floating-point\n        let left; // amount of space from left edge, a fraction of the total width\n        let right; // amount of space from right edge, a fraction of the total width\n        if (shouldOverlap) {\n            // double the width, but don't go beyond the maximum forward coordinate (1.0)\n            farCoord = Math.min(1, nearCoord + (farCoord - nearCoord) * 2);\n        }\n        if (isRtl) {\n            left = 1 - farCoord;\n            right = nearCoord;\n        }\n        else {\n            left = nearCoord;\n            right = 1 - farCoord;\n        }\n        let props = {\n            zIndex: segHCoords.stackDepth + 1,\n            left: left * 100 + '%',\n            right: right * 100 + '%',\n        };\n        if (shouldOverlap && !segHCoords.stackForward) {\n            // add padding to the edge so that forward stacked events don't cover the resizer's icon\n            props[isRtl ? 'marginLeft' : 'marginRight'] = 10 * 2; // 10 is a guesstimate of the icon's width\n        }\n        return props;\n    }\n}\nfunction renderPlainFgSegs(sortedFgSegs, { todayRange, nowDate, eventSelection, eventDrag, eventResize }) {\n    let hiddenInstances = (eventDrag ? eventDrag.affectedInstances : null) ||\n        (eventResize ? eventResize.affectedInstances : null) ||\n        {};\n    return (createElement(Fragment, null, sortedFgSegs.map((seg) => {\n        let instanceId = seg.eventRange.instance.instanceId;\n        return (createElement(\"div\", { key: instanceId, style: { visibility: hiddenInstances[instanceId] ? 'hidden' : '' } },\n            createElement(TimeColEvent, Object.assign({ seg: seg, isDragging: false, isResizing: false, isDateSelecting: false, isSelected: instanceId === eventSelection, isShort: false }, getSegMeta(seg, todayRange, nowDate)))));\n    })));\n}\nfunction computeSegVStyle(segVCoords) {\n    if (!segVCoords) {\n        return { top: '', bottom: '' };\n    }\n    return {\n        top: segVCoords.start,\n        bottom: -segVCoords.end,\n    };\n}\nfunction compileSegsFromEntries(segEntries, allSegs) {\n    return segEntries.map((segEntry) => allSegs[segEntry.index]);\n}\n\nclass TimeColsContent extends BaseComponent {\n    constructor() {\n        super(...arguments);\n        this.splitFgEventSegs = memoize(splitSegsByCol);\n        this.splitBgEventSegs = memoize(splitSegsByCol);\n        this.splitBusinessHourSegs = memoize(splitSegsByCol);\n        this.splitNowIndicatorSegs = memoize(splitSegsByCol);\n        this.splitDateSelectionSegs = memoize(splitSegsByCol);\n        this.splitEventDrag = memoize(splitInteractionByCol);\n        this.splitEventResize = memoize(splitInteractionByCol);\n        this.rootElRef = createRef();\n        this.cellElRefs = new RefMap();\n    }\n    render() {\n        let { props, context } = this;\n        let nowIndicatorTop = context.options.nowIndicator &&\n            props.slatCoords &&\n            props.slatCoords.safeComputeTop(props.nowDate); // might return void\n        let colCnt = props.cells.length;\n        let fgEventSegsByRow = this.splitFgEventSegs(props.fgEventSegs, colCnt);\n        let bgEventSegsByRow = this.splitBgEventSegs(props.bgEventSegs, colCnt);\n        let businessHourSegsByRow = this.splitBusinessHourSegs(props.businessHourSegs, colCnt);\n        let nowIndicatorSegsByRow = this.splitNowIndicatorSegs(props.nowIndicatorSegs, colCnt);\n        let dateSelectionSegsByRow = this.splitDateSelectionSegs(props.dateSelectionSegs, colCnt);\n        let eventDragByRow = this.splitEventDrag(props.eventDrag, colCnt);\n        let eventResizeByRow = this.splitEventResize(props.eventResize, colCnt);\n        return (createElement(\"div\", { className: \"fc-timegrid-cols\", ref: this.rootElRef },\n            createElement(\"table\", { role: \"presentation\", style: {\n                    minWidth: props.tableMinWidth,\n                    width: props.clientWidth,\n                } },\n                props.tableColGroupNode,\n                createElement(\"tbody\", { role: \"presentation\" },\n                    createElement(\"tr\", { role: \"row\" },\n                        props.axis && (createElement(\"td\", { \"aria-hidden\": true, className: \"fc-timegrid-col fc-timegrid-axis\" },\n                            createElement(\"div\", { className: \"fc-timegrid-col-frame\" },\n                                createElement(\"div\", { className: \"fc-timegrid-now-indicator-container\" }, typeof nowIndicatorTop === 'number' && (createElement(NowIndicatorContainer, { elClasses: ['fc-timegrid-now-indicator-arrow'], elStyle: { top: nowIndicatorTop }, isAxis: true, date: props.nowDate })))))),\n                        props.cells.map((cell, i) => (createElement(TimeCol, { key: cell.key, elRef: this.cellElRefs.createRef(cell.key), dateProfile: props.dateProfile, date: cell.date, nowDate: props.nowDate, todayRange: props.todayRange, extraRenderProps: cell.extraRenderProps, extraDataAttrs: cell.extraDataAttrs, extraClassNames: cell.extraClassNames, extraDateSpan: cell.extraDateSpan, fgEventSegs: fgEventSegsByRow[i], bgEventSegs: bgEventSegsByRow[i], businessHourSegs: businessHourSegsByRow[i], nowIndicatorSegs: nowIndicatorSegsByRow[i], dateSelectionSegs: dateSelectionSegsByRow[i], eventDrag: eventDragByRow[i], eventResize: eventResizeByRow[i], slatCoords: props.slatCoords, eventSelection: props.eventSelection, forPrint: props.forPrint }))))))));\n    }\n    componentDidMount() {\n        this.updateCoords();\n    }\n    componentDidUpdate() {\n        this.updateCoords();\n    }\n    updateCoords() {\n        let { props } = this;\n        if (props.onColCoords &&\n            props.clientWidth !== null // means sizing has stabilized\n        ) {\n            props.onColCoords(new PositionCache(this.rootElRef.current, collectCellEls(this.cellElRefs.currentMap, props.cells), true, // horizontal\n            false));\n        }\n    }\n}\nfunction collectCellEls(elMap, cells) {\n    return cells.map((cell) => elMap[cell.key]);\n}\n\n/* A component that renders one or more columns of vertical time slots\n----------------------------------------------------------------------------------------------------------------------*/\nclass TimeCols extends DateComponent {\n    constructor() {\n        super(...arguments);\n        this.processSlotOptions = memoize(processSlotOptions);\n        this.state = {\n            slatCoords: null,\n        };\n        this.handleRootEl = (el) => {\n            if (el) {\n                this.context.registerInteractiveComponent(this, {\n                    el,\n                    isHitComboAllowed: this.props.isHitComboAllowed,\n                });\n            }\n            else {\n                this.context.unregisterInteractiveComponent(this);\n            }\n        };\n        this.handleScrollRequest = (request) => {\n            let { onScrollTopRequest } = this.props;\n            let { slatCoords } = this.state;\n            if (onScrollTopRequest && slatCoords) {\n                if (request.time) {\n                    let top = slatCoords.computeTimeTop(request.time);\n                    top = Math.ceil(top); // zoom can give weird floating-point values. rather scroll a little bit further\n                    if (top) {\n                        top += 1; // to overcome top border that slots beyond the first have. looks better\n                    }\n                    onScrollTopRequest(top);\n                }\n                return true;\n            }\n            return false;\n        };\n        this.handleColCoords = (colCoords) => {\n            this.colCoords = colCoords;\n        };\n        this.handleSlatCoords = (slatCoords) => {\n            this.setState({ slatCoords });\n            if (this.props.onSlatCoords) {\n                this.props.onSlatCoords(slatCoords);\n            }\n        };\n    }\n    render() {\n        let { props, state } = this;\n        return (createElement(\"div\", { className: \"fc-timegrid-body\", ref: this.handleRootEl, style: {\n                // these props are important to give this wrapper correct dimensions for interactions\n                // TODO: if we set it here, can we avoid giving to inner tables?\n                width: props.clientWidth,\n                minWidth: props.tableMinWidth,\n            } },\n            createElement(TimeColsSlats, { axis: props.axis, dateProfile: props.dateProfile, slatMetas: props.slatMetas, clientWidth: props.clientWidth, minHeight: props.expandRows ? props.clientHeight : '', tableMinWidth: props.tableMinWidth, tableColGroupNode: props.axis ? props.tableColGroupNode : null /* axis depends on the colgroup's shrinking */, onCoords: this.handleSlatCoords }),\n            createElement(TimeColsContent, { cells: props.cells, axis: props.axis, dateProfile: props.dateProfile, businessHourSegs: props.businessHourSegs, bgEventSegs: props.bgEventSegs, fgEventSegs: props.fgEventSegs, dateSelectionSegs: props.dateSelectionSegs, eventSelection: props.eventSelection, eventDrag: props.eventDrag, eventResize: props.eventResize, todayRange: props.todayRange, nowDate: props.nowDate, nowIndicatorSegs: props.nowIndicatorSegs, clientWidth: props.clientWidth, tableMinWidth: props.tableMinWidth, tableColGroupNode: props.tableColGroupNode, slatCoords: state.slatCoords, onColCoords: this.handleColCoords, forPrint: props.forPrint })));\n    }\n    componentDidMount() {\n        this.scrollResponder = this.context.createScrollResponder(this.handleScrollRequest);\n    }\n    componentDidUpdate(prevProps) {\n        this.scrollResponder.update(prevProps.dateProfile !== this.props.dateProfile);\n    }\n    componentWillUnmount() {\n        this.scrollResponder.detach();\n    }\n    queryHit(positionLeft, positionTop) {\n        let { dateEnv, options } = this.context;\n        let { colCoords } = this;\n        let { dateProfile } = this.props;\n        let { slatCoords } = this.state;\n        let { snapDuration, snapsPerSlot } = this.processSlotOptions(this.props.slotDuration, options.snapDuration);\n        let colIndex = colCoords.leftToIndex(positionLeft);\n        let slatIndex = slatCoords.positions.topToIndex(positionTop);\n        if (colIndex != null && slatIndex != null) {\n            let cell = this.props.cells[colIndex];\n            let slatTop = slatCoords.positions.tops[slatIndex];\n            let slatHeight = slatCoords.positions.getHeight(slatIndex);\n            let partial = (positionTop - slatTop) / slatHeight; // floating point number between 0 and 1\n            let localSnapIndex = Math.floor(partial * snapsPerSlot); // the snap # relative to start of slat\n            let snapIndex = slatIndex * snapsPerSlot + localSnapIndex;\n            let dayDate = this.props.cells[colIndex].date;\n            let time = addDurations(dateProfile.slotMinTime, multiplyDuration(snapDuration, snapIndex));\n            let start = dateEnv.add(dayDate, time);\n            let end = dateEnv.add(start, snapDuration);\n            return {\n                dateProfile,\n                dateSpan: Object.assign({ range: { start, end }, allDay: false }, cell.extraDateSpan),\n                dayEl: colCoords.els[colIndex],\n                rect: {\n                    left: colCoords.lefts[colIndex],\n                    right: colCoords.rights[colIndex],\n                    top: slatTop,\n                    bottom: slatTop + slatHeight,\n                },\n                layer: 0,\n            };\n        }\n        return null;\n    }\n}\nfunction processSlotOptions(slotDuration, snapDurationOverride) {\n    let snapDuration = snapDurationOverride || slotDuration;\n    let snapsPerSlot = wholeDivideDurations(slotDuration, snapDuration);\n    if (snapsPerSlot === null) {\n        snapDuration = slotDuration;\n        snapsPerSlot = 1;\n        // TODO: say warning?\n    }\n    return { snapDuration, snapsPerSlot };\n}\n\nclass DayTimeColsSlicer extends Slicer {\n    sliceRange(range, dayRanges) {\n        let segs = [];\n        for (let col = 0; col < dayRanges.length; col += 1) {\n            let segRange = intersectRanges(range, dayRanges[col]);\n            if (segRange) {\n                segs.push({\n                    start: segRange.start,\n                    end: segRange.end,\n                    isStart: segRange.start.valueOf() === range.start.valueOf(),\n                    isEnd: segRange.end.valueOf() === range.end.valueOf(),\n                    col,\n                });\n            }\n        }\n        return segs;\n    }\n}\n\nclass DayTimeCols extends DateComponent {\n    constructor() {\n        super(...arguments);\n        this.buildDayRanges = memoize(buildDayRanges);\n        this.slicer = new DayTimeColsSlicer();\n        this.timeColsRef = createRef();\n    }\n    render() {\n        let { props, context } = this;\n        let { dateProfile, dayTableModel } = props;\n        let isNowIndicator = context.options.nowIndicator;\n        let dayRanges = this.buildDayRanges(dayTableModel, dateProfile, context.dateEnv);\n        // give it the first row of cells\n        // TODO: would move this further down hierarchy, but sliceNowDate needs it\n        return (createElement(NowTimer, { unit: isNowIndicator ? 'minute' : 'day' }, (nowDate, todayRange) => (createElement(TimeCols, Object.assign({ ref: this.timeColsRef }, this.slicer.sliceProps(props, dateProfile, null, context, dayRanges), { forPrint: props.forPrint, axis: props.axis, dateProfile: dateProfile, slatMetas: props.slatMetas, slotDuration: props.slotDuration, cells: dayTableModel.cells[0], tableColGroupNode: props.tableColGroupNode, tableMinWidth: props.tableMinWidth, clientWidth: props.clientWidth, clientHeight: props.clientHeight, expandRows: props.expandRows, nowDate: nowDate, nowIndicatorSegs: isNowIndicator && this.slicer.sliceNowDate(nowDate, context, dayRanges), todayRange: todayRange, onScrollTopRequest: props.onScrollTopRequest, onSlatCoords: props.onSlatCoords })))));\n    }\n}\nfunction buildDayRanges(dayTableModel, dateProfile, dateEnv) {\n    let ranges = [];\n    for (let date of dayTableModel.headerDates) {\n        ranges.push({\n            start: dateEnv.add(date, dateProfile.slotMinTime),\n            end: dateEnv.add(date, dateProfile.slotMaxTime),\n        });\n    }\n    return ranges;\n}\n\n// potential nice values for the slot-duration and interval-duration\n// from largest to smallest\nconst STOCK_SUB_DURATIONS = [\n    { hours: 1 },\n    { minutes: 30 },\n    { minutes: 15 },\n    { seconds: 30 },\n    { seconds: 15 },\n];\nfunction buildSlatMetas(slotMinTime, slotMaxTime, explicitLabelInterval, slotDuration, dateEnv) {\n    let dayStart = new Date(0);\n    let slatTime = slotMinTime;\n    let slatIterator = createDuration(0);\n    let labelInterval = explicitLabelInterval || computeLabelInterval(slotDuration);\n    let metas = [];\n    while (asRoughMs(slatTime) < asRoughMs(slotMaxTime)) {\n        let date = dateEnv.add(dayStart, slatTime);\n        let isLabeled = wholeDivideDurations(slatIterator, labelInterval) !== null;\n        metas.push({\n            date,\n            time: slatTime,\n            key: date.toISOString(),\n            isoTimeStr: formatIsoTimeString(date),\n            isLabeled,\n        });\n        slatTime = addDurations(slatTime, slotDuration);\n        slatIterator = addDurations(slatIterator, slotDuration);\n    }\n    return metas;\n}\n// Computes an automatic value for slotLabelInterval\nfunction computeLabelInterval(slotDuration) {\n    let i;\n    let labelInterval;\n    let slotsPerLabel;\n    // find the smallest stock label interval that results in more than one slots-per-label\n    for (i = STOCK_SUB_DURATIONS.length - 1; i >= 0; i -= 1) {\n        labelInterval = createDuration(STOCK_SUB_DURATIONS[i]);\n        slotsPerLabel = wholeDivideDurations(labelInterval, slotDuration);\n        if (slotsPerLabel !== null && slotsPerLabel > 1) {\n            return labelInterval;\n        }\n    }\n    return slotDuration; // fall back\n}\n\nclass DayTimeColsView extends TimeColsView {\n    constructor() {\n        super(...arguments);\n        this.buildTimeColsModel = memoize(buildTimeColsModel);\n        this.buildSlatMetas = memoize(buildSlatMetas);\n    }\n    render() {\n        let { options, dateEnv, dateProfileGenerator } = this.context;\n        let { props } = this;\n        let { dateProfile } = props;\n        let dayTableModel = this.buildTimeColsModel(dateProfile, dateProfileGenerator);\n        let splitProps = this.allDaySplitter.splitProps(props);\n        let slatMetas = this.buildSlatMetas(dateProfile.slotMinTime, dateProfile.slotMaxTime, options.slotLabelInterval, options.slotDuration, dateEnv);\n        let { dayMinWidth } = options;\n        let hasAttachedAxis = !dayMinWidth;\n        let hasDetachedAxis = dayMinWidth;\n        let headerContent = options.dayHeaders && (createElement(DayHeader, { dates: dayTableModel.headerDates, dateProfile: dateProfile, datesRepDistinctDays: true, renderIntro: hasAttachedAxis ? this.renderHeadAxis : null }));\n        let allDayContent = (options.allDaySlot !== false) && ((contentArg) => (createElement(DayTable, Object.assign({}, splitProps.allDay, { dateProfile: dateProfile, dayTableModel: dayTableModel, nextDayThreshold: options.nextDayThreshold, tableMinWidth: contentArg.tableMinWidth, colGroupNode: contentArg.tableColGroupNode, renderRowIntro: hasAttachedAxis ? this.renderTableRowAxis : null, showWeekNumbers: false, expandRows: false, headerAlignElRef: this.headerElRef, clientWidth: contentArg.clientWidth, clientHeight: contentArg.clientHeight, forPrint: props.forPrint }, this.getAllDayMaxEventProps()))));\n        let timeGridContent = (contentArg) => (createElement(DayTimeCols, Object.assign({}, splitProps.timed, { dayTableModel: dayTableModel, dateProfile: dateProfile, axis: hasAttachedAxis, slotDuration: options.slotDuration, slatMetas: slatMetas, forPrint: props.forPrint, tableColGroupNode: contentArg.tableColGroupNode, tableMinWidth: contentArg.tableMinWidth, clientWidth: contentArg.clientWidth, clientHeight: contentArg.clientHeight, onSlatCoords: this.handleSlatCoords, expandRows: contentArg.expandRows, onScrollTopRequest: this.handleScrollTopRequest })));\n        return hasDetachedAxis\n            ? this.renderHScrollLayout(headerContent, allDayContent, timeGridContent, dayTableModel.colCnt, dayMinWidth, slatMetas, this.state.slatCoords)\n            : this.renderSimpleLayout(headerContent, allDayContent, timeGridContent);\n    }\n}\nfunction buildTimeColsModel(dateProfile, dateProfileGenerator) {\n    let daySeries = new DaySeriesModel(dateProfile.renderRange, dateProfileGenerator);\n    return new DayTableModel(daySeries, false);\n}\n\nexport { DayTimeCols, DayTimeColsSlicer, DayTimeColsView, TimeCols, TimeColsSlatsCoords, TimeColsView, buildDayRanges, buildSlatMetas, buildTimeColsModel };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}